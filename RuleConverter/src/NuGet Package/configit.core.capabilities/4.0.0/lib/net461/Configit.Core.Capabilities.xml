<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Configit.Core.Capabilities</name>
    </assembly>
    <members>
        <member name="T:Configit.Core.Capabilities.BasicSolve.BasicSolver">
            <summary>
            Provides a very thin and lightweight wrapping of <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>, 
            that together with <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest"/> tracks actual values of assignments
            as opposed to just finite domain values.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolver.InternalSolver">
            <summary>
            The <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> used internally be this <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolver"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolver.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver)">
            <summary>
            Wraps the provided solver.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolver.SupportedFeatures">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.SupportedFeatures"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolver.PublicVariables">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.PublicVariables"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolver.Solve(Configit.Core.Capabilities.BasicSolve.BasicSolveRequest,Configit.Core.Capabilities.BasicSolve.BasicSolveResponse)">
            <summary>
            <para>Main solve method, which populates a <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse"/>
            object with the result of solving against the provided <paramref name="request"/>. </para>
            <para>If no <paramref name="response"/> object is provided, a new <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse"/>
            object is automatically created. However, for performance reasons, it is recommended to
            re-use any existing response objects, as these might be expensive to create.</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolver.CreateRequest">
            <summary>
            Creates a solve request objects used to hold all information used when solving.
            A request object is designed to be re-used, as it might be expensive to create.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolver.CreateResponse">
            <summary>
            Creates a solve response objects used to hold the result of all information used when solving.
            A response object is designed to be re-used, as it might be expensive to create.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest">
            <summary>
            Wraps a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/> keeping track of the actual values
            assigned, as opposed to the finite domain indices assigned. Uses variable names
            instead of variable indices.
            <remarks>
            Changes made to the underlying <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.InternalRequest"/> will not
            be reflected correctly in this wrapper. It is intended for access
            by <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolver"/> only.
            </remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.Assignments">
            <summary>
            Stores specific assignments to <see cref="P:Configit.Core.Model.IEntityWithId.Id"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.Completions">
            <summary>
            Stores completions by <see cref="P:Configit.Core.Model.IEntityWithId.Id"/>, their
            priority is stored directly in the underlying request.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.InternalRequest">
            <summary>
            Assignments added directly to the underlying <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>
            will not be represented in <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest"/>. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest)">
            <summary>
            Wraps the provided <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.AddAssignment(System.String,System.Object)">
            <summary>
            Add specific assignment to public variable as disjunctive assignment. To
            ensure only a single assignment exist for the specified variable, call
            <see cref="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.SetAssignment(System.String,System.Object)"/> instead.
            </summary>
            <returns>The finite domain index assigned, or -1 if the value does
            not exist in the domain and wasn't applied.
            </returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="publicVariable"/> is not a known public
            variable.</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.SetAssignment(System.String,System.Object)">
            <summary>
            Remove any existing assignment to variable, and set defined <paramref name="value"/> as
            the only assigned value.
            </summary>
            <returns>The finite domain index assigned, or -1 if the value does
            not exist in the domain and wasn't applied. In this case, any existing assignments
            are still deleted.
            </returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="variable"/> is not a known public
            variable.</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.RemoveAssignments(System.String)">
            <summary>
            Removes assignments to the given variable.
            </summary>
            <returns>True if assignments were removed</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="variable"/> is not a known public
            variable.</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.HasAssignment(System.String,System.Object)">
            <summary>
            Test if specific <paramref name="value"/> is assigned to <paramref name="variable"/>.
            Value might be a disjunctively assigned value. Value could either be user 
            assigned by a user or by a completion.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.HasAssignment(System.String)">
            <summary>
            Returns true if <paramref name="publicVariable"/> has any values assigned to it.
            </summary>
            <returns>True if one or more values are assigned to <paramref name="publicVariable"/></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="publicVariable"/> is not a known in
            <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.PublicVariables"/></exception>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.ResetAllAssignments">
            <summary>
            Remove all assignment to all public variables
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.ResetCompletions">
            <summary>
            Resets all completions set using <see cref="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.SetCompletion(System.String,System.Object,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.Reset">
            <summary>
            Performs a complete reset of the domain request, ensuring that
            its content matches that of calling <see cref="M:Configit.Core.Capabilities.BasicSolve.BasicSolver.CreateRequest"/>
            Compared to <see cref="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.ResetAllAssignments"/>, this method also reset
            assignment and completion sequence
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.AssignmentSequence">
            <summary>
            <para>Sequence of public variables that controls order in which variable assignments
            are applied. Variables first in list takes precedence over later variables.</para>
            <para>Set this property to null to reset the assignment sequence to the default sequence which depends on the solver in use.</para>
            <para>The sequence is given as a list of variable collections. Variables in the same collection has the same order in the
            sequence, indicating that their internal ordering in the group is irrelevant.</para>
            <remarks>Sequenced variables that are not assigned are ignored</remarks>
            <example>Given { {A,B},{C,D} }, assignments to variables A and B take precedence
            over variables C and D, but the underlying
            <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> is free to use its preferred sequence within each group.
            I.e. if the assignments to A and B are in conflict, then no guarantee
            is given as to which one will be reported as conflicting.</example>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.Complete">
            <summary>
            <para>
            Complete the configuration using the value priorities defined in completion sequence
            and completion cost.
            </para>
            <para>
            Complete only attempts to assign a value to a variable if it does not already have a user assignment
            (disjoined or not). Values not considered for completion
            can still be inferred but they wont be user assigned.</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.ComputeSolutionCount">
            <summary>
            If true, the <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.SolutionCount"/> property
            will be updated.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.PublicVariables">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.PublicVariables"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.RemoveCompletion(System.String)">
            <summary>
            Removes completion assignments from the given variable.
            Note that this doesn't affect the active assignments, but does
            update <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/> on <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.InternalRequest"/>.
            </summary>
            <returns>
            True if a completion was removed.
            </returns>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.SetCompletion(System.String,System.Object,System.Int32)">
            <summary>
            Sets the completion order of a given value. Supplying a negative
            number ensures that the values is not used for completion.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="variable"/> does not exist</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.GetCompletion(System.String,System.Object)">
            <summary>
            Returns the current completion order of the specified variable, value pair or -1 if
            no completion has been set or if the <paramref name="value"/> does not
            exist in the domain of <paramref name="variable"/>
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="variable"/> does not exist</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.HasAnyAssignments">
            <summary>
            Checks if any assignment has been made in the request
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.GetSingleAssignedValue(System.String)">
            <summary>
            If exactly one value is assigned, returns the assigned value.
            If multiple values are disjointly assigned, this method returns null
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.GetAssignedValues(System.String)">
            <summary>
            Returns all assigned values for a given variable
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.Prioritize(System.String)">
            <summary>
            <para>
            Put <paramref name="publicVariable"/> first in <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.AssignmentSequence"/>, 
            ensuring that any assignments to <paramref name="publicVariable"/> will be prioritized
            over assignments to any other variables.
            </para>
            <para>Note that <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.AssignmentSequence"/> is not changed
            when calling <see cref="M:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.ResetAllAssignments"/>, meaning the variable
            will remain prioritized, even though assignments are changed.</para>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse">
            <summary>
            Wraps a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/>, using variable names 
            and value objects to communicate values instead of indices.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.AcceptedAssignments">
            <summary>
            Contains mapping of variable id to list of accepted assigned values
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <summary>
            Wraps the <paramref name="response"/> object
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.InternalResponse">
            <summary>
            Assignments added directly to the underlying <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/>
            will not be represented in <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse"/>. 
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.ConflictingVariables">
            <summary>
            Indices of public variables with conflicting assignments that had to be removed to make 
            the configuration valid
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.GetUnconstrained(System.String,System.Object)">
            <summary>
            <para>Returns true if value <paramref name="value"/> of <paramref name="publicVar"/>
            is valid according to the assignments in the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>.
            </para>
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.PublicVariables"/> does not contain <paramref name="publicVar"/></exception>
            <exception cref="T:System.ArgumentException">If <paramref name="publicVar"/> does not contain <paramref name="value"/>
            in its domain.</exception>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.SolutionCount">
            <summary>
            Number of solutions satisfying <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest"/>. This value 
            is only set if <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveRequest.ComputeSolutionCount"/> is
            set to true. Otherwise, this value is 0.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.PublicVariables">
            <summary>
            Catalog of public variables
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.IsCompleteAssigned(System.String,System.Object)">
            <summary>
            Indicates if <paramref name="value"/> is completed during solve due to <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest.Complete"/>
            being set to true.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.HasAcceptedAssignment(System.String,System.Object)">
            <summary>
            Indicates if <paramref name="value"/> represents an accepted assignment to
            <paramref name="publicVariable"/>. Accepted assignments are those
            which have not been removed as a conflict.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.HasAcceptedAssignment(System.String)">
            <summary>
            Returns true if there are any accepted assignments to <paramref name="publicVariable"/>.
            Accepted assignments are those assignments
            from the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest"/> which have not been removed as a conflict. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.GetSpecificValue(System.String)">
            <summary>
            Get value which is either an accepted assigned value or an inferred value. Value returned
            can be an interval.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="variable"/> does not exist in 
            <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.PublicVariables"/></exception>
            <returns>Value which is either assigned or the inferred. Null if multiple 
            values are assigned or if no specific value is inferred.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.GetAcceptedAssignment(System.String)">
            <summary>
            If exactly one value has been accepted as assigned to <paramref name="publicVariable"/>, 
            get value. If no value has been accepted as an assignment, or if multiple values have been
            accepted, null is returned. Does not get inferred value, only assigned or 
            completed value.
            </summary>
            <param name="publicVariable"></param>
            <returns></returns>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.GetInferred(System.String)">
            <summary>
            If a single value is left unconstrained in the domain of <paramref name="variable"/>
            the <see cref="T:Configit.Core.Model.ValueDefinitions.IValue"/> representing this unconstrained value is returned, otherwise
            null is returned. Notice that returned value might be an interval.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="variable"/> is not a known in 
            <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.PublicVariables"/></exception>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.HasSingletonValue(System.String)">
            <summary>
            Returns true if a single specific singleton value is inferred or assigned to the given variable
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.GetSingletonValue(System.String)">
            <summary>
            Get singleton value which is either assigned or inferred.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If <paramref name="variable"/> does not exist in 
            <see cref="P:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.PublicVariables"/></exception>
            <returns>Value which is either assigned or is inferred and is a singleton. Null if multiple 
            values are assigned or, if no specific value is inferred or if inferred value is 
            not a singleton.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.GetAcceptedAssignments(System.String)">
            <summary>
            Get all assignment to <paramref name="publicVariable"/> which has been accepted. This
            includes both user assignments and assignments added as a consequence of complete.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.AfterComplete(Configit.Core.Utils.Base.OneToManyDictionary{System.String,Configit.Core.Model.ValueDefinitions.IValue})">
            <summary>
            If assignments have been added as a consequence of a completion, these
            assignments need to be copied to the <see cref="T:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse"/>
            </summary>
            <param name="completions"></param>
        </member>
        <member name="T:Configit.Core.Capabilities.BasicSolve.NamespaceDoc">
            <summary>
            Simple sover API, acting as a light-weight solve capability for easy
            to use configurators
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.BddExtensions">
            <summary>
            Provides <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> specific extensions to the <see cref="T:Configit.Core.Noddy.Bdd"/> class
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BddExtensions.ToDynamicNdd(Configit.Core.Noddy.Bdd)">
            <summary>
            Get <see cref="T:Configit.Core.Structure.Ndd.DynamicNdd"/> representing same solution space as BDD.Before
            a <see cref="T:Configit.Core.Noddy.Bdd"/> can be converted into an <see cref="T:Configit.Core.Structure.Ndd.DynamicNdd"/> finite domains must be specified
            using <see cref="P:Configit.Core.Noddy.Noddy.FiniteVarDomains"/>. Domain constraints are automatically 
            applied before turning <paramref name="bdd"/> into an <see cref="T:Configit.Core.Structure.Ndd.DynamicNdd"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.BddExtensions.ToNdd(Configit.Core.Noddy.Bdd)">
            <summary>
            Get <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> representing same solution space as this BDD. Before
            a <see cref="T:Configit.Core.Noddy.Bdd"/> can be converted into an <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> finite domains must be specified
            using <see cref="P:Configit.Core.Noddy.Noddy.FiniteVarDomains"/>. Domain constraints are automatically 
            applied before turning <paramref name="bdd"/> into an <see cref="T:Configit.Core.Structure.Ndd.Ndd"/>.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.CacheContainer">
            <summary>
            Default implementation of <see cref="T:Configit.Core.Capabilities.Utilities.ICacheContainer"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.CacheContainer.GetCache``1(System.Guid,System.Func{``0})">
            <summary>
            Gets or creates a specific cache.
            </summary>
            <param name="guid">Unique identifier for the cache.</param>
            <param name="createCache">Callback for creating the cache if it doesn't exist.</param>
            <typeparam name="T">Cache type</typeparam>
        </member>
        <member name="T:Configit.Core.Capabilities.CompiledCapabilityFactory">
            <summary>
            Used for mapping <see cref="T:Configit.Core.Model.ICompiledData"/> to the <see cref="T:Configit.Core.Model.ICompiledCapability"/> that consumes them.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.#ctor">
            <summary>
            Creates the default runtime factory
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapabilities``1(Configit.Core.Model.PackagedModel)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapability``1(Configit.Core.Model.PackagedModel,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapabilities``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapabilities``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},Configit.Core.Model.VariableCatalog)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapability``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapability``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},Configit.Core.Model.VariableCatalog)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapability``1(Configit.Core.Model.ICompiledData,Configit.Core.Model.VariableCatalog)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.CompiledCapabilityFactory.GetCapability``1(Configit.Core.Model.ICompiledData,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.BddToNddConverter">
            <summary>
            Converter for transforming a specific <see cref="T:Configit.Core.Noddy.Bdd"/> into an <see cref="T:Configit.Core.Structure.Ndd.Ndd"/>.
            Each conversion requires a new converter instance.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.#ctor(Configit.Core.Noddy.Noddy,System.Int32)">
            <summary>
            Create converter that can convert specified Bdd root into an Ndd
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.Convert">
            <summary>
            Create <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> representing the root Bdd
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.BuildNodesAndEdges">
            <summary>
            Build an Ndd node for each top root, and create edges representing
            the paths from one top root to another.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.BuildEdgesForNode(System.Int32,System.Int32)">
            <summary>
            Find all paths from one top root the next top roots / terminals. Create edges
            for all paths and insert jump nodes where applied.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.CreateValuesForPath(System.Int32,System.Int32)">
            <summary>
            Identify all possible values represented by given path
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.GetNddNodeNumber(System.Int32,System.Int32)">
            <summary>
            Given a top root (positive index) or a jump root (negative index),
            get the Ndd node number represented by it.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.FindTopRoots">
            <summary>
            Identify nodes in Bdd (top roots) that are to become nodes in Ndd. No
            jump nodes are found during this iteration.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.FindTopRootsRec(System.Int32,System.Int32)">
            <summary>
            Recursive search for top roots
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.FindJumpNodes">
            <summary>
            Find all jump roots, and insert as negative entries in topRoots. Each entry
            indicates a node that jumps to the node with the negated index (the negated
            index is a root that belongs to a variable further down the graph).
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.FindJumpNodesRec(System.Int32,System.Int32)">
            <summary>
            Recursive method for finding jump nodes and inserting in topRoots
            as negative entries.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.BuildNddVariables">
            <summary>
            Calculate number of nodes used for each fd variable, and
            initialize variables array
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddToNddConverter.InitializeMembers">
            <summary>
            Initialize all arrays and lists used for building Ndd.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Converters.BddToNddConverter.FdOperator">
            <summary>
            Access to information about finite domain variables
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Converters.BddToNddConverter.Kernel">
            <summary>
            Bdd kernel instance
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.BddValidValuesExtensions">
            <summary>
            Extensions for getting valid values of a <see cref="T:Configit.Core.Noddy.Bdd"/> in a more human
            readable format
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddValidValuesExtensions.GetValidValues(Configit.Core.Noddy.Bdd,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Find valid values for <paramref name="bdd"/> using <see cref="M:Configit.Core.Noddy.Bdd.GetValidValues"/>.
            Index of variables and values are translated into Ids of the variables and values. Result
            only contains entries for variables which are in the <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/>
            of the <paramref name="bdd"/>. If all values of a variable are allowed in the Bdd, 
            the resulting value enumeration is returned as null (
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.BddValidValuesExtensions.GetValidValuesAsString(Configit.Core.Noddy.Bdd,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Use <see cref="M:Configit.Core.Capabilities.Converters.BddValidValuesExtensions.GetValidValues(Configit.Core.Noddy.Bdd,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition})"/> to obtain valid values for all variables, and convert all indices
            into Ids. This method is provided for debug purposes, to get a textual representation of all valid 
            values
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.EnumerationConversionException">
            <summary>
            Thrown when trying to create a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionEnumeration"/> containing 
            "any-value" for a string variable or "not these values" for a string variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.EnumerationConversionException.ToString">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.NamespaceDoc">
            <summary>
            Helper classes for converting between data structures used by differente configuration
            capabilities.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.NddToBddConverter">
            <summary>
            Converter for transforming a specific <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> into a <see cref="T:Configit.Core.Noddy.Bdd"/>.
            Each conversion requires a new converter instance.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToBddConverter.BddForNode(System.Int32,System.Int32)">
            <summary>
            Build Bdd representing Ndd node. Result is reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToBddConverter.IsNodeComplete(System.Int32)">
            <summary>
            Return true if node only has complete edge pointing from it
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.NddToDaogConverter">
            <summary>
            Converts <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> to <see cref="T:Configit.Core.Structure.Daog.Daog"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToDaogConverter.Convert(Configit.Core.Structure.Ndd.Ndd)">
            <summary>
            Converts the provided <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> to a corresponding <see cref="T:Configit.Core.Structure.Daog.Daog"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.NddToSolutionSpaceConverter">
            <summary>
            Converter for transforming a specific <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> into a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionSpace"/>.
            Each conversion requires a new converter instance.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToSolutionSpaceConverter.#ctor(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Configit.Core.Model.ValueDefinitions.IValue}})">
            <summary>
            Create converter for specific <paramref name="ndd"/>.
            </summary>
            <param name="ndd">Representation of valid values to create solution space for</param>
            <param name="modelVariables">List of model variables, which must match sequence of variables used in the given <paramref name="ndd"/></param>
            <param name="multiValuedGroups">Definition of multi-valued groups, used to create the resulting <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionSpaceVariable"/> object</param>
            <param name="domainFilters">Optional filters used to trim the valid domains of number and date-time variables.
            The domains in the resulting <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionSpace"/> will for each filtered variable in
            each solution represent the intersection of the valid domain and the given filter. If
            a number variable is e.g. assigned interval [1;3] and the valid domain for the number variable in
            a given solution is [-10;20] (given that is how the domains are "cut" by the rules), the resulting valid
            domain in the solution space will be [1;3]. Note: if any solution for any filtered variable is
            disjoined with the filter (the intersection of the filter and the original valid domain is empty), then
            an <see cref="T:System.ArgumentException"/> is thrown.</param>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToSolutionSpaceConverter.ToSolutionCpr">
            <summary>
            Convert provided NDD into a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionCpr"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToSolutionSpaceConverter.ToSolutionEnumeration">
            <summary>
            Convert provided NDD into a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionEnumeration"/>
            </summary>
            <exception cref="T:Configit.Core.Capabilities.Converters.EnumerationConversionException"> if solution space contains any solution where
            a string variable can accept any value</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToSolutionSpaceConverter.ToSolutionGraph">
            <summary>
            Convert provided NDD into a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionGraph"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.NddToSolutionSpaceConverter.NddValueIndicesToValues(Configit.Core.Model.VariableDefinitions.IVariableDefinition,System.Collections.Generic.IEnumerable{System.Int32},System.Boolean@)">
            <summary>
            Convert a list of domain valid value indices for a given <paramref name="variable"/> into 
            a corresponding list of <see cref="T:Configit.Core.Model.ValueDefinitions.IValue"/> objects, where intervals are merged 
            (for date time / number) and string values for string variables are handled. 
            Sets <paramref name="includeValues"/> to indicate if the result should be considered 
            a negative list (in case of string variables).
            </summary>
            <returns>Collection of <see cref="T:Configit.Core.Model.ValueDefinitions.IValue"/> representing valid values, or null to represent that all values
            in domain are valid.</returns>
        </member>
        <member name="T:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter">
            <summary>
            Conversion from <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionSpace"/> to <see cref="T:Configit.Core.Noddy.Bdd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.ToBdd(Configit.Core.Structure.SolutionSpace.SolutionSpace,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,Configit.Core.Noddy.Noddy)">
            <summary>
            Convert <paramref name="solutionSpace"/> to a <see cref="T:Configit.Core.Noddy.Bdd"/> with the same
            solutions. Result belongs to the given <paramref name="noddy"/> instance.
            Variables are translated from the <paramref name="solutionSpace"/> to model
            variables using <paramref name="variables"/>
            </summary>
            <returns>A <see cref="T:Configit.Core.Noddy.Bdd"/> with the same values as <paramref name="solutionSpace"/> or 
            <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/> in case <paramref name="solutionSpace"/> is null.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.ToBdd(Configit.Core.Structure.SolutionSpace.SolutionCpr,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,Configit.Core.Noddy.Noddy)">
            <summary>
            Convert <paramref name="cpr"/> to a <see cref="T:Configit.Core.Noddy.Bdd"/> with the same
            solutions. Result belongs to the given <paramref name="noddy"/> instance (if provided).
            Variables are translated from the <paramref name="cpr"/> to model
            variables using <paramref name="variables"/>
            </summary>
            <returns>A <see cref="T:Configit.Core.Noddy.Bdd"/> with the same values as <paramref name="cpr"/> or 
            <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/> in case <paramref name="cpr"/> is null.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.ToBdd(Configit.Core.Structure.SolutionSpace.SolutionEnumeration,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,Configit.Core.Noddy.Noddy)">
            <summary>
            Convert <paramref name="enumeration"/> to a <see cref="T:Configit.Core.Noddy.Bdd"/> with the same
            solutions. Result belongs to the given <paramref name="noddy"/> instance (if provided).
            Variables are translated from the <paramref name="enumeration"/> to model
            variables using <paramref name="variables"/>
            </summary>
            <returns>A <see cref="T:Configit.Core.Noddy.Bdd"/> with the same values as <paramref name="enumeration"/> or 
            <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/> in case <paramref name="enumeration"/> is null.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.ToBdd(Configit.Core.Structure.SolutionSpace.SolutionGraph,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,Configit.Core.Noddy.Noddy)">
            <summary>
            Convert <paramref name="graph"/> to a <see cref="T:Configit.Core.Noddy.Bdd"/> with the same
            solutions. Result belongs to the given <paramref name="noddy"/> instance (if provided).
            Variables are translated from the <paramref name="graph"/> to model
            variables using <paramref name="variables"/>
            </summary>
            <returns>A <see cref="T:Configit.Core.Noddy.Bdd"/> with the same values as <paramref name="graph"/> or 
            <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/> in case <paramref name="graph"/> is null.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.NodeToBdd(System.Int32,Configit.Core.Structure.SolutionSpace.SolutionGraph,Configit.Core.Noddy.Noddy,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,Configit.Core.Noddy.Bdd[])">
            <summary>
            Convert a single <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionGraphNode"/> to BDD
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.GetVariableDefinition(Configit.Core.Structure.SolutionSpace.SolutionSpaceVariable,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet)">
            <summary>
            Get variable definition. Handle multi valued variables
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.ValuesToBdd(Configit.Core.Noddy.Noddy,Configit.Core.Model.VariableDefinitions.IVariableDefinition,System.Int32,System.Collections.Generic.IEnumerable{Configit.Core.Model.ValueDefinitions.IValue},System.Boolean)">
            <summary>
            Convert collection of disjointly assigned <paramref name="values"/> to <paramref name="variable"/>
            into a <see cref="T:Configit.Core.Noddy.Bdd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Converters.SolutionSpaceToBddConverter.ValueToBdd(Configit.Core.Noddy.Noddy,Configit.Core.Model.VariableDefinitions.IVariableDefinition,System.Int32,Configit.Core.Model.ValueDefinitions.IValue)">
            <summary>
            Convert <paramref name="value"/> assigned to <paramref name="variable"/>
            into a <see cref="T:Configit.Core.Noddy.Bdd"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.IDefaultApplier">
            <summary>
            Interface provided to <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultSource"/> to apply default values. It allows
            "forward-only" assignment of defaults, meaning that a default provider cannot re-assign.
            <remarks>
            The interface does not expose the <see cref="T:Configit.Core.Model.VariableDefinitions.MultiValuedGroup"/> concept, instead
            query and assign the underlying Boolean variables.
            </remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.IsAvailable(System.String,System.Object)">
            <summary>
            Returns true if the given variable and value is available without changing any existing assignments
            (including assignments to <paramref name="variable"/>).
            <remarks>
            Note the difference with <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.GetUnconstrained(System.Int32,System.Int32)"/>, as the solver will indicate
            a value as unconstrained if it can be achieved by changing the assignment of the variable to which
            the value belongs. The check in this method only returns true if no existing assignments
            would be changed if assigning <paramref name="value"/> to <paramref name="variable"/>.
            </remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.HasSpecificSingletonValue(System.String)">
            <summary>
            Returns true if a single specific singleton value is inferred or assigned to the given variable.
            </summary>
            <seealso cref="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.HasSingletonValue(System.String)"/>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.GetSpecificSingletonValue(System.String)">
            <summary>
            Returns the single singleton value assigned or inferred 
            for the indicated variable, or null if multiple 
            values are available of if intervals are inferred. 
            </summary>
            <seealso cref="M:Configit.Core.Capabilities.BasicSolve.BasicSolveResponse.GetSingletonValue(System.String)"/>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.IDefaultApplier.RelevantVariables">
            <summary>
            The variables to consider for defaults. 
            When using phased solves, only the variables in the current phase will be relevant.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.FilterToRelevant(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Filters against <see cref="P:Configit.Core.Capabilities.Defaults.IDefaultApplier.RelevantVariables"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.ApplyDefaults">
            <summary>
            Attempts to apply any pending defaults added by <see cref="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.EnqueueDefaults(System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.Assignment})"/>.
            After calling this method, <see cref="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.IsAvailable(System.String,System.Object)"/> will reflect the new assignments.
            It is allowed (and will improve performance significantly) to supply multiple defaults for the same variable (with
            different priority).
            </summary>
            <returns>Default assignments that were applied, 
            assignment matching existing assignments are not returned. 
            Note that the priority of the returned assignments will 
            have been normalized among <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultSource"/>s.
            </returns>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.EnqueueDefaults(System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.Assignment})">
            <summary>
            Appends assignments to the list of defaults to attempt. The defaults are resolved
            once <see cref="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.ApplyDefaults"/> is called, either by a <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultSource"/> or once
            all <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultSource"/>s have been processed.
            
            Appended defaults will always respect the <see cref="P:Configit.Core.Capabilities.Defaults.IDefaultSource.Priority"/>, even if no 
            call is made to <see cref="M:Configit.Core.Capabilities.Defaults.IDefaultApplier.ApplyDefaults"/> by the <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultSource"/>s.
            <example>
            Source A has priority 10
            Source B has priority 5
            
            If A appends X=1 with priority 0 and B appends X = 2 with priority 100, then X=1 will apply 
            with higher priority than X = 2 due to the priority of its source.
            </example>
            </summary>
            <param name="defaultAssignments">Defaults to append</param>
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.IDefaultData">
            <summary>
            Marker interface indicating that the data can be used for creating
            a <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultSource"/>.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.IDefaultData.Priority">
            <summary>
            Default data sets with higher priority takes precedence over those with lower.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.IDefaultSource">
            <summary>
            Interface implemented by providers of default values. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.IDefaultSource.ApplyDefaults(Configit.Core.Capabilities.Defaults.IDefaultApplier)">
            <summary>
            This method is called by the logic handling defaults during the solve process.
            It provide a <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultApplier"/> that can be used to investigate 
            allowed values, and allows multiple iterations of attempting prioritized
            defaults.
            </summary>
            <param name="defaultApplier">Interface for accessing the state of the configuration.</param>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.IDefaultSource.Priority">
            <summary>
            When a model contains multiple default providers the <see cref="P:Configit.Core.Capabilities.Defaults.IDefaultSource.Priority"/> indicates
            in which order they should be executed. Since a default provider cannot change existing defaults,
            this means that higher priority providers get to decide first and can rely on those defaults not
            being changed later.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.NamespaceDoc">
            <summary>
            Capability that can work apply defaults to a configuration
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.ScopedDefaultData">
            <summary>
            Data source for <see cref="T:Configit.Core.Capabilities.Defaults.ScopedDefaultSource"/>.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.Id">
            <summary>
            Identifier of entity
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.TypeIdentifier">
            <inheritdoc />
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.ScopeVariables">
            <summary>
            Scope variables that drives defaults. Values to these variables are assigned to
            the default solver ( which is created using <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.SolveData"/>)
            in order to deduce if any values can be inferred for any of the <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.RelevantVariables"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.SolveData">
            <summary>
            <para>
            The <see cref="T:Configit.Core.Model.ICompiledData"/> for the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> that derives default values.
            This solver must match the domains provided in the <see cref="T:Configit.Core.Model.VariableCatalog"/> of
            <see cref="M:Configit.Core.Capabilities.Defaults.ScopedDefaultSource.#ctor(Configit.Core.Capabilities.Defaults.ScopedDefaultData,Configit.Core.Model.VariableCollection,Configit.Core.Capabilities.ICompiledCapabilityFactory)"/>.
            </para>
            <para>
            If the configuration of the <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.ScopeVariables"/> causes a conflict in the default solver,
            (a solver created using <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.SolveData"/>) the <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/> are applied attempted
            without modification.
            </para>
            <para>
            If the configuration of the <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.ScopeVariables"/> does not cause a conflict in the
            default solver, then each variable in <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.RelevantVariables"/> that is inferred by the default
            solver will be given a default value corresponding to the inferred value.
            These inferred default assignments will be given a higher
            priority than any default assignment in <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/>. The priority internally between
            the inferred default values depends on the existence of <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/>. If
            <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/> exist then the sequence of the variables as they
            appear in the <see cref="T:Configit.Core.Model.VariableDefinitions.Assignment"/> in <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/> is used.
            If <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/> is not specified,
            then the sequence of the variables in the <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.RelevantVariables"/> is used.
            </para>
            <example>
            If the <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/> order is Y=1, Y=2, X=1, X=2, X=3 and X=2 is inferred in the default solver
            with both Y=1 and Y=2 being available then the active order is
            X=2, Y=1, Y=2, X=1, X=3. If Y=2 is also inferred, then the active order is Y=2, X=2, Y=1, X=1, X=3
            </example>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults">
            <summary>
            Base defaults used when the default solver does not infer a value for certain variables.
            Each variable can be given multiple base defaults (prioritize these to specify which value is preferred).
            <remarks>
            It is allowed to include defaults for the scope variables.
            </remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.RelevantVariables">
            <summary>
            <para>
            List of variables for which defaults are applied. Even though <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.SolveData"/>
            might infer values for many values, only the variables explicitly mentioned in
            <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.RelevantVariables"/> will have defaults applied.
            </para>
            <para>Relevant variables can be specified either explicitly, or be deduced from the
            provided set of <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/>.</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.Priority">
            <summary>
            Default data sets with higher priority takes precedence over those with lower.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.SolveDataVariables">
            <summary>
            Variable collection for <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.SolveData"/>. If not populated it means
            the collection matches the top level variable definitions as per the public
            variables in <see cref="P:Configit.Core.Model.PackagedModel.Variables"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.ScopedDefaultData.#ctor(System.Collections.Generic.IEnumerable{System.String},Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.IValidDomainSolveData,System.Collections.Generic.IReadOnlyList{Configit.Core.Model.VariableDefinitions.Assignment},System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},System.String,System.Int32)">
            <summary>
            Data consumed by <see cref="T:Configit.Core.Capabilities.Defaults.ScopedDefaultSource"/> to calculate defaults.
            </summary>
            <remarks>Exactly one of <paramref name="baseDefaults"/> or <paramref name="relevantVariables"/> must be specified</remarks>
            <param name="scopeVariableIds">The variables that drive the defaults.</param>
            <param name="solveData">The default solver that derives the assignment to boost in priority.</param>
            <param name="baseDefaults">Optional list of <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.BaseDefaults"/>. Cannot be specified in
            connection with <paramref name="relevantVariables"/>
            </param>
            <param name="relevantVariables">Optional list of variables, for which defaults are to be applied. If
            this list is not specified, the <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.RelevantVariables"/> is deduced from the set of
            variables in <paramref name="baseDefaults "/> that contains an assignment. Cannot be specified in
            connection with <paramref name="baseDefaults"/>.</param>
            <param name="solveDataVariables">Variable definitions for the default solver in <paramref name="solveData"/>.
            Must be specified if the default solver finite domains does not match the top level solver, otherwise optional.</param>
            <param name="id">Unique identifier within the <see cref="T:Configit.Core.Model.PackagedModel"/>, defaults to <see cref="M:System.Guid.NewGuid"/></param>
            <param name="sourcePriority"><see cref="P:Configit.Core.Capabilities.Defaults.IDefaultSource.Priority"/></param>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.ScopedDefaultData.NormalizePriorities(System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.Assignment})">
            <summary>
            Generates contiguous priorities.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.ScopedDefaultSource">
            <summary>
            Default applier supporting partially dynamic defaults.
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.Defaults.ScopedDefaultSource._defaultSolver">
            <summary>
            <see cref="P:Configit.Core.Capabilities.Defaults.ScopedDefaultData.SolveData"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.ScopedDefaultSource.#ctor(Configit.Core.Capabilities.Defaults.ScopedDefaultData,Configit.Core.Model.VariableCollection,Configit.Core.Capabilities.ICompiledCapabilityFactory)">
            <param name="data">See <see cref="T:Configit.Core.Capabilities.Defaults.ScopedDefaultData"/></param>
            <param name="topLevelPublicVariables">Variables as per <see cref="P:Configit.Core.Model.PackagedModel.Variables"/></param>
            <param name="factory"><see cref="T:Configit.Core.Capabilities.CompiledCapabilityFactory"/> used to setup the underlying default solver</param>
        </member>
        <member name="F:Configit.Core.Capabilities.Defaults.ScopedDefaultSource.SolverCacheGuid">
            <summary>
            <see cref="M:Configit.Core.Capabilities.Utilities.ICacheContainer.GetCache``1(System.Guid,System.Func{``0})"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.Defaults.ScopedDefaultSource._defaultSolverVariables">
            <summary>
            
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.ScopedDefaultSource.ApplyDefaults(Configit.Core.Capabilities.Defaults.IDefaultApplier)">
            <summary>
            This method is called by the logic handling defaults during the solve process.
            It provide an <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultApplier"/> that can be used to investigate
            allowed values, and allows multiple iterations of attempting prioritized
            defaults.
            </summary>
            <param name="defaultApplier">Interface for accessing the state of the configuration.</param>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.ScopedDefaultSource.Priority">
            <summary>
            When a model contains multiple default providers the <see cref="P:Configit.Core.Capabilities.Defaults.IDefaultSource.Priority"/> indicates
            in which order they should be executed. Since a default provider cannot change existing defaults,
            this means that higher priority providers get to decide first and can rely on those defaults not
            being changed later.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.StaticDefaultData">
            <summary>
            Static prioritized defaults, providing data for<see cref="T:Configit.Core.Capabilities.Defaults.StaticDefaultSource"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.StaticDefaultData.#ctor(System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.Assignment},System.String,System.Int32)">
            <param name="assignments">Static defaults to apply. The <see cref="P:Configit.Core.Model.VariableDefinitions.Assignment.Priority"/> determines
            the sequence in which the defaults are attempted.</param>
            <param name="id">
            Optional identifier, must be unique among 
            <see cref="T:Configit.Core.Model.ICompiledData"/> in the same <see cref="T:Configit.Core.Model.PackagedModel"/></param>
            <param name="priority">Higher priority number takes precedence over lower priority number.</param>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.StaticDefaultData.Defaults">
            <summary>
            Statically prioritized default assignments.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.StaticDefaultData.Priority">
            <summary>
            Default data sets with higher priority takes precedence over those with lower.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.StaticDefaultData.Id">
            <summary>
            Identifier of entity
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Defaults.StaticDefaultData.TypeIdentifier">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Defaults.StaticDefaultSource">
            <summary>
            Provides static (ie. independent of the configuration) defaults.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.StaticDefaultSource.#ctor(Configit.Core.Capabilities.Defaults.StaticDefaultData)">
            <summary>
            Create static default 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Defaults.StaticDefaultSource.ApplyDefaults(Configit.Core.Capabilities.Defaults.IDefaultApplier)">
            <summary>
            This method is called by the logic handling defaults during the solve process.
            It provide a <see cref="T:Configit.Core.Capabilities.Defaults.IDefaultApplier"/> that can be used to investigate 
            allowed values, and allows multiple iterations of attempting prioritized
            defaults.
            </summary>
            <param name="defaultApplier">Interface for accessing the state of the configuration.</param>
        </member>
        <member name="T:Configit.Core.Capabilities.Disposable`1">
            <summary>
            Wraps a non <see cref="T:System.IDisposable"/> object as an <see cref="T:System.IDisposable"/>.
            This is used with <see cref="T:Configit.Core.Utils.Base.ResourcePool.ResourcePool`1"/> which currently requires items to be <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Disposable`1.Value">
            <summary>
            The object that is made disposable
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Disposable`1.#ctor(`0)">
            <summary>
            Create a new disposable wrapper for <paramref name="value"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Disposable`1.Dispose">
            <summary>
            Dummy dispose methods that does nothing
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Disposable`1.op_Implicit(Configit.Core.Capabilities.Disposable{`0})~`0">
            <summary>
            Implicit conversion of wrapped disposable object to actual 
            wrapped object
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Disposable`1.op_Implicit(`0)~Configit.Core.Capabilities.Disposable{`0}">
            <summary>
            Wrap <paramref name="value"/> as disposable object
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.DynamicNddExtensions">
            <summary>
            Extension methods working on <see cref="T:Configit.Core.Structure.Ndd.DynamicNdd"/> objects, and to converting
            to <see cref="T:Configit.Core.Noddy.Bdd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.DynamicNddExtensions.ToBdd(Configit.Core.Structure.Ndd.DynamicNdd,Configit.Core.Noddy.Noddy)">
            <summary>
            Get <see cref="T:Configit.Core.Noddy.Bdd"/> representing the same solution space as this <paramref name="dynNdd"/>. 
            If a <paramref name="noddy"/> instance is provided, the definition of the <see cref="P:Configit.Core.Noddy.Noddy.FdVars"/>
            is validated against the <see cref="P:Configit.Core.Structure.Ndd.DynamicNdd.VariableDomains"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.DynamicNddExtensions.PrintAsDot(Configit.Core.Structure.Ndd.DynamicNdd,Configit.Core.Structure.Ndd.NddDotOptions)">
            <summary>
            Get string representing DynamicNdd in Graphviz format. 
            </summary>
            <seealso cref="M:Configit.Core.Capabilities.DynamicNddExtensions.PrintAsDot(Configit.Core.Structure.Ndd.DynamicNdd,Configit.Core.Structure.Ndd.NddDotOptions)"/>
        </member>
        <member name="M:Configit.Core.Capabilities.DynamicNddExtensions.PrintAsDot(Configit.Core.Structure.Ndd.DynamicNdd,System.String,Configit.Core.Structure.Ndd.NddDotOptions)">
            <summary>
            Print the DynamicNdd in Graphviz format as a directed graph. Output to
            specified file.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.DynamicNddExtensions.PrintAsDot(Configit.Core.Structure.Ndd.DynamicNdd,System.IO.TextWriter,Configit.Core.Structure.Ndd.NddDotOptions)">
            <summary>
            Print the Dynamic NDD in Graphviz format as a directed graph. Output to 
            specified stream.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData">
            <summary>
            Compiled data used to support finding an unsatisfiable core using BDDs in 
            <see cref="T:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreFinder"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData.#ctor(System.Collections.Generic.IEnumerable{System.Linq.ILookup{Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd}},System.Linq.ILookup{Configit.Core.Noddy.Bdd,System.String},System.String)">
            <summary>
            Creates data used for finding an unsatisfiable core with <see cref="T:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreFinder"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData.ProcessedBddsChain">
            <summary>
            <para>
            Chained collections of processed BDDs. The keys in each link (entry) represents
            a processing step. The values in each link are identical to keys in the next
            link. The values in the last link in the chain contains BDDs that are 
            used with the map <see cref="P:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData.BddToRule"/>. Often, the last link are the 
            original rule BDDs, in which case the link represents the identity mapping.
            </para>
            <para>Typical links would be: simplified to merged, merged to split,
            split to original rule BDDs, original rule BDD identity map.
            </para>
            <para>If source IL model does not contain any rules, or if all rules are trivially true, 
            the chain will be null</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData.BddToRule">
            <summary>
            Maps a BDD in the values of the last entry in <see cref="P:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData.ProcessedBddsChain"/>
            to the set of names for the rules that it originated from.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData.Id">
            <inheritdoc />
        </member>
        <member name="F:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData.TypeIdentifier">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreFinder">
            <summary>
            Class capable of finding rules that makes a specific Boolean expression unsatisfiable. 
            The input is some solution space that in conjunction with the rules are unsatisfiable, 
            the output is a reference to the original rules in the source IL model.
            This class is implemented using by running <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.FindUnsatCore(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},Configit.Core.Noddy.Bdd,System.Int32)"/> 
            on multiple batches of processed BDDs.
            </summary> 
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreFinder.#ctor(Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreData)">
            <summary>
            Input data can contain any number of chained processed BDDs. The input BDDs can 
            be defined both with and without finite domain variables. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreFinder.FindUnsatCore(Configit.Core.Noddy.Bdd,System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Capabilities.Explain.IUnsatCoreFinder.FindUnsatCore(Configit.Core.Noddy.Bdd,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreFinder.PruneCore(System.Collections.Generic.List{Configit.Core.Noddy.Bdd})">
            <summary>
            Run through all BDDs in core, and check if any BDD can be removed
            </summary>
            <returns>New core where all non-required BDDs are removed</returns>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.BddSatisfyUnsatCoreFinder.Noddy">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.ExplainStep">
            <summary>
            A step in the explanation corresponding to applying a single rule or to applying the current state.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStep.#ctor(System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.Explain.ExplainStepVariableEffect},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.Explain.ExplainStepAssignment})">
            <summary>
            Constructs an explain step for the given <paramref name="ruleNames"/> and <paramref name="variableEffects"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStep.#ctor(Configit.Core.Model.VariableDefinitions.IVariableDefinition)">
            <summary>
            Constructs an explain step for a system assigned value of a variable with only one value.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStep.RuleIds">
            <summary>
            Contains logic model rule identifiers for each rule involved in the step.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStep.Assignments">
            <summary>
            Contains assignments involved in the current step. Assignments here are 
            part of the target assignments being explained. When <see cref="P:Configit.Core.Capabilities.Explain.ExplainStep.Assignments"/> are given
            no <see cref="P:Configit.Core.Capabilities.Explain.ExplainStep.RuleIds"/> are used. Assignments are only ever set when
            target represents multiple assignments
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStep.VariableEffects">
            <summary>
            The relevant state changes for relevant variables when applying the rule (or the initial state) in this step.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStep.ToString">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.ExplainStepAssignment">
            <summary>
            Represents an assignment used in an <see cref="T:Configit.Core.Capabilities.Explain.StepByStepExplanation"/> or <see cref="T:Configit.Core.Capabilities.Explain.ExplainStep"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStepAssignment.#ctor(Configit.Core.Model.VariableDefinitions.IVariableDefinition,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create an assignment representing disjunctive assignments of
            a set of values to specified variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStepAssignment.#ctor(Configit.Core.Model.VariableDefinitions.IVariableDefinition,System.Int32)">
            <summary>
            Create an assignment of the value to specified variable.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStepAssignment.Variable">
            <summary>
            The Variable this class applies to.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStepAssignment.Values">
            <summary>
            The assigned values.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStepAssignment.ToString">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.ExplainStepVariableEffect">
            <summary>
            Describes the effect of an <see cref="T:Configit.Core.Capabilities.Explain.ExplainStep"/> on a given variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStepVariableEffect.#ctor(Configit.Core.Model.VariableDefinitions.IVariableDefinition,System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates an explain step effect for a given variable.
            </summary>
            <param name="variable">Affected variable</param>
            <param name="systemAssignedValue">(Optional) value inferred for variable</param>
            <param name="availableValues">(Optional) values still available after this step</param>
            <param name="unavailableValues">(Optional) values made unavailable in step</param>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStepVariableEffect.Variable">
            <summary>
            The variable that this class applies to.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStepVariableEffect.SystemAssignedValue">
            <summary>
            If the step forces a single value, this property returns this value, -1 otherwise.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStepVariableEffect.UnavailableValues">
            <summary>
            The list of values that became unavailable in this step.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.ExplainStepVariableEffect.AvailableValues">
            <summary>
            The list of values still available after this step.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplainStepVariableEffect.ToString">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.ExplanationGenerator">
            <summary>
            Responsible for generating a full step-by-step explanation at the logic model level, based
            on the unsat core found by a <see cref="T:Configit.Core.Capabilities.Explain.IUnsatCoreFinder"/>
            <remarks>
            The step-by-step explanation has not been implemented yet.
            </remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplanationGenerator.#ctor(Configit.Core.Capabilities.Explain.IUnsatCoreFinder,Configit.Core.Model.VariableCatalog)">
            <summary>
            Creates an explanation generator that uses a specific <see cref="T:Configit.Core.Capabilities.Explain.IUnsatCoreFinder"/> and 
            hence a fixed set of base rules.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplanationGenerator.ExplainWhy(System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Boolean,System.Int32)">
            <summary>
            Creates an explanation for why a set of target assignments are not possible given another set of assignments.
            </summary>
            <param name="stateAssignments">A set of assignments giving the state under which to inspect <paramref name="targetAssignments"/>. 
            (that is, under the configuration that <paramref name="targetAssignments"/> are investigated.</param>
            <param name="targetAssignments">The assignments to explain why they are either inferred or
            not available (depending on <paramref name="explainWhyNot"/>)</param>
            <param name="explainWhyNot">If true, explains why <paramref name="targetAssignments"/> 
            cannot be achieved. If false, explains why it is inferred.</param>
            <param name="preProcessConjoinLimit">Limit used when pre-conjoining BDDs when checking for 
            satisfiability using <see cref="M:Configit.Core.Noddy.Noddy.IsSatisfiable(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)"/></param>
            <returns>null if the rules and the provided state and change are not unsatisfiable,
            a populated explanation object otherwise.</returns>
            <remarks>To make this service easy to consume, all assignments in <paramref name="stateAssignments"/>
            for which the variable is also assigned in <paramref name="targetAssignments"/> is removed
            automatically. This makes it possible to explain both blocked and forcible value B=B2 in state: A=A1,B=B1
            (in both cases, the assignment to B has no influence). When explaining why e.g. B=B2 is inferred (when
            <paramref name="explainWhyNot"/> is false), the assignment B=B1 would not make sense in current <paramref name="stateAssignments"/>.
            </remarks>
            <remarks>
            If <paramref name="targetAssignments"/> is specified, and its assignments can be explained without <paramref name="stateAssignments"/>, 
            then no attempt will be made to explain <paramref name="stateAssignments"/>. 
            </remarks>
            <remarks>All assignments must be given in public variable space.</remarks>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplanationGenerator.CreateSteps(System.Collections.Generic.IDictionary{System.String,Configit.Core.Noddy.Bdd},System.Collections.Generic.List{System.Int32},Configit.Core.Noddy.Bdd,System.Collections.Generic.List{Configit.Core.Capabilities.UserAssignment},System.Boolean)">
            <summary>
            Divides the rules in <paramref name="rules"/> into steps, by applying one rule at a time to the state.
            If applying a rule has an effect on the state, i.e. it changes the available values a step is created.
            The step creation tries to minimize the number of rules in a step by applying a rule first if it alone 
            has an effect on the current state.
            </summary>
            <param name="rules">The rules making <paramref name=" initialStateBdd"/> false if applied</param>
            <param name="variables">The variables relevant to the explanation</param>
            <param name="initialStateBdd">The initial state before applying core</param>
            <param name="target">The set of assignments to be explained</param>
            <param name="explainWhyNot">If true, explains why <paramref name="target"/> 
            cannot be achieved. If false, explains why it is inferred.</param>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplanationGenerator.TryRemoveVariable(System.Int32,System.Collections.Generic.List{Configit.Core.Noddy.Bdd}@)">
            <summary>
            Removes the given <paramref name="variable"/> from the given <paramref name="rules"/>
            using existential quantification if the conjunction of the <paramref name="rules"/> is False
            after removing the variable.
            <returns>True if the variable has been removed from the rule using existential quantification</returns> 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.ExplanationGenerator.ExplainWhyNot(System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Int32)">
            <summary>
            Shortcut for calling <see cref="M:Configit.Core.Capabilities.Explain.ExplanationGenerator.ExplainWhy(System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Boolean,System.Int32)"/> with explainWhyNot = true.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.IUnsatCoreData">
            <summary>
            Data supporting obtaining an unsatisfiable core for a satisfiability problem, reporting
            answer as a set of rules in original input model.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.IUnsatCoreFinder">
            <summary>
            Entity capable of finding rules that makes a specific Boolean expression unsatisfiable. 
            The input is some solution space that in conjunction with the rules are unsatisfiable, 
            the output is a reference to the original rules in the source IL model.
            </summary>  
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.IUnsatCoreFinder.FindUnsatCore(Configit.Core.Noddy.Bdd,System.Int32)">
            <summary>
            Find the (hopefully smallest) set BDDs and their corresponding rule that in conjunction
            makes the <paramref name="target"/> unsatisfiable. As each rule might be represented with
            multiple BDDs after compilation, the output might not include all BDDs for all rules
            and might contain BDDs that belongs to several rules.
            </summary>
            <param name="target">Definition of the state we are investigating. State could e.g. be a blocked
            value or a combination of values that the rules disallows. </param>
            <param name="preProcessConjoinLimit">Limit used when pre-conjoining BDDs when checking for 
            satisfiability using <see cref="M:Configit.Core.Noddy.Noddy.IsSatisfiable(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)"/></param>
            <returns>Null if not target conjoined with state conjoined with all rules are satisfiable, or
            a list of <see cref="T:Configit.Core.Noddy.Bdd"/> instances and the name of the original IL rule they were generated
            from. Note that each IL rule might be described by multiple BDDs, meaning that each
            rule name might appear multiple times in the result.</returns>
            <exception cref="T:System.ArgumentException">If target is false by itself</exception>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.IUnsatCoreFinder.Noddy">
            <summary>
            Returns the underlying <see cref="T:Configit.Core.Noddy.Noddy"/> instance, to allow callers to allocate
            <see cref="T:Configit.Core.Noddy.Bdd"/> instances in the same <see cref="T:Configit.Core.Noddy.Noddy"/> instance.
            </summary>
            <remarks>If underlying data contains no BDDs, a new empty Noddy instance is created</remarks>
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.NamespaceDoc">
            <summary>
            Capability that can reason over the current state of specific values in a given configuration
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Explain.StepByStepExplanation">
            <summary>
            Step-by-step explanation in terms of logic model variables and rules
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.StepByStepExplanation.#ctor(System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.Explain.ExplainStepAssignment},System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.Explain.ExplainStep})">
            <summary>
            An explanation represented by a list relevant variables and a list of explain steps
            </summary>
            <param name="state">A set of assignments representing the state originating this Explanation</param>
            <param name="relevantVariables">List of variables relevant to the explanation</param>
            <param name="steps">List of steps to use in explanation</param>
            <exception cref="T:System.ArgumentNullException">If steps is null</exception>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.StepByStepExplanation.State">
            <summary>
            A set of user assignments representing the state originating this Explanation
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.StepByStepExplanation.RelevantVariables">
            <summary>
            Returns the variables relevant to the explanation. The individual <see cref="P:Configit.Core.Capabilities.Explain.StepByStepExplanation.Steps"/>
            might contain rules which mention other variables, but only variables
            included in <see cref="P:Configit.Core.Capabilities.Explain.StepByStepExplanation.RelevantVariables"/> are relevant to explain why the input
            target (variable, value pairs) were in the given state.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.StepByStepExplanation.Steps">
            <summary>
            Provides a step-by-step explanation. The step-by-step explanation is
            provided to make it easier to consume how applying a set of rules to
            a given state end up with putting the target variable, value pairs in
            the given state.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Explain.StepByStepExplanation.RuleNames">
            <summary>
            Returns the rule names over all the explanation steps (i.e. simply the unsatisfiable core)
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Explain.StepByStepExplanation.ToString">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.ExplainWhy.UserAssignment">
            <summary>
            Represents a disjoined assignment to a specific variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ExplainWhy.UserAssignment.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create an user assignment representing disjunctive assignments of 
            a set of values to specified variable. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ExplainWhy.UserAssignment.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an user assignment representing the specified value assigned to the
            specified variable.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ExplainWhy.UserAssignment.Variable">
            <summary>
            IL index of variable
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ExplainWhy.UserAssignment.ValueIndices">
            <summary>
            IL index of values
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ExplainWhy.UserAssignment.Values">
            <summary>
            Actual values assigned.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ExplainWhy.UserAssignment.Count">
            <summary>
            Number of values in assignment. If more than 1, the values are disjointly 
            assigned
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ExplainWhy.UserAssignment.GetValue(System.Int32)">
            <summary>
            Returns the finite domain value stored in the input assignment given an index into the values in the assignment
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ExplainWhy.UserAssignment.GetValueIndex(System.Int32)">
            <summary>
            Returns the finite domain value index given an index into the values in the assignment
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ExplainWhy.UserAssignment.IsFinite">
            <summary>
            Is the variable a finite variable. 
            </summary>
            <remarks>
            For finite variables the methods <see cref="M:Configit.Core.Capabilities.ExplainWhy.UserAssignment.GetValue(System.Int32)"/> and <see cref="M:Configit.Core.Capabilities.ExplainWhy.UserAssignment.GetValueIndex(System.Int32)"/> 
            are equal and <see cref="P:Configit.Core.Capabilities.ExplainWhy.UserAssignment.Values"/> and <see cref="P:Configit.Core.Capabilities.ExplainWhy.UserAssignment.ValueIndices"/> return an IEnumerable 
            with same the objects.
            </remarks>
        </member>
        <member name="T:Configit.Core.Capabilities.ICompiledCapabilityFactory">
            <summary>
            Interface representing a factory that can produce <see cref="T:Configit.Core.Model.ICompiledCapability"/> for use at runtime
            based on <see cref="T:Configit.Core.Model.ICompiledData"/> as stored in <see cref="T:Configit.Core.Model.PackagedModel"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.RegisterConversion``2(System.Func{``0,Configit.Core.Model.VariableCatalog,``1})">
            <summary>
            Registers a conversion from from <typeparamref name="TInput"/> to <typeparamref name="TOutput"/>. 
            <typeparamref name="TOutput"/> must define a constructor taking a parameter of type <typeparamref name="TInput"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapabilities``1(Configit.Core.Model.PackagedModel)">
            <summary>
            Returns all <see cref="T:Configit.Core.Model.ICompiledCapability"/> instances of type <typeparamref name="TCapability"/> 
            that can be created from any of the <see cref="T:Configit.Core.Model.ICompiledData"/> in the <see cref="T:Configit.Core.Model.PackagedModel"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapability``1(Configit.Core.Model.PackagedModel,System.String)">
            <summary>
            Get first <see cref="T:Configit.Core.Model.ICompiledCapability"/> instance of type <typeparamref name="TCapability"/> 
            that can be created from any of the <see cref="T:Configit.Core.Model.ICompiledData"/> in the <see cref="T:Configit.Core.Model.PackagedModel"/>
            <returns>First instance that can be created, or null if no instance can be created</returns>
            </summary>
            <param name="packagedModel">The model containing the <see cref="T:Configit.Core.Model.ICompiledData"/></param>
            <param name="specificId">A specific <see cref="P:Configit.Core.Model.IEntityWithId.Id"/> to generate the <typeparamref name="TCapability"/> for.</param>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapabilities``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Get all capabilities of the indicated type from the provided set of <see cref="T:Configit.Core.Model.ICompiledData"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapabilities``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},Configit.Core.Model.VariableCatalog)">
            <summary>
            Get all capabilities of the indicated type from the provided set of <see cref="T:Configit.Core.Model.ICompiledData"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapability``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},Configit.Core.Model.VariableCatalog)">
            <summary>
            Get first <see cref="T:Configit.Core.Model.ICompiledCapability"/> instance of type <typeparamref name="TCapability"/> 
            that can be created from any of the <see cref="T:Configit.Core.Model.ICompiledData"/> supplied in <paramref name="data"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapability``1(System.Collections.Generic.IEnumerable{Configit.Core.Model.ICompiledData},System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Get first <see cref="T:Configit.Core.Model.ICompiledCapability"/> instance of type <typeparamref name="TCapability"/> 
            that can be created from any of the <see cref="T:Configit.Core.Model.ICompiledData"/> supplied in <paramref name="data"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapability``1(Configit.Core.Model.ICompiledData,Configit.Core.Model.VariableCatalog)">
            <summary>
            Get first <see cref="T:Configit.Core.Model.ICompiledCapability"/> instance of type <typeparamref name="TCapability"/> 
            that can be created from the <see cref="T:Configit.Core.Model.ICompiledData"/> supplied in <paramref name="data"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ICompiledCapabilityFactory.GetCapability``1(Configit.Core.Model.ICompiledData,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Get first <see cref="T:Configit.Core.Model.ICompiledCapability"/> instance of type <typeparamref name="TCapability"/> 
            that can be created from the <see cref="T:Configit.Core.Model.ICompiledData"/> supplied in <paramref name="data"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.NamespaceDoc">
            <summary>
            Classes supporting different capabilities for when working on a compiled model
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.NddEnumerationData">
            <summary>
            Data used during solution enumeration of an <see cref="P:Configit.Core.Capabilities.NddEnumerationData.Ndd"/>. Each instance of
            this data is tied to a specific instance of an <see cref="P:Configit.Core.Capabilities.NddEnumerationData.Ndd"/>. If an <see cref="P:Configit.Core.Capabilities.NddEnumerationData.Ndd"/>
            is enumerated multiple times, instances of this data can be re-used to avoid
            re-allocation of required data.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.NddEnumerationData.LastIncludedUsedVariable">
            <summary>
            Index of last variable to include in result which is marked as used in the NDD
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.NddEnumerationData.LastAssignedUsedVariable">
            <summary>
            Largest used variable we have any assignments to, or -1 if we have no assignments
            to any used variables
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.NddEnumerationData.LastIncludedVariable">
            <summary>
            Index of last variable to include in result
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.NddEnumerationData.VarIsAssigned">
            <summary>
            Indication if variable has any assignments
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.NddEnumerationData.VariablesToInclude">
            <summary>
            Result will only contain columns for variables that are marked to be included
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.NddEnumerationData.Ndd">
            <summary>
            The <see cref="P:Configit.Core.Capabilities.NddEnumerationData.Ndd"/> instance tied to this instance of data
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.NddEnumerationData.UseNullForWildcard">
            <summary>
            Indication if we return null in cells when all values are allowed for a variable, or return an
            enumeration with all the values.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.#ctor(Configit.Core.Structure.Ndd.Ndd)">
            <summary>
            Create data used to enumerate solutions for the specific
            <paramref name="ndd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.NodeCouldBeValid(System.Int32,System.Int32)">
            <summary>
            Return true if given <paramref name="node"/> could be valid (meaning
            it has not yet been determined, that it is not valid
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.#ctor(Configit.Core.Structure.Ndd.Ndd,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment})">
            <summary>
            Constructor used to create an initialize data for specific <paramref name="ndd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.NodeVisitedBefore(System.Int32,System.Int32)">
            <summary>
            Return true if node has been visited before, used by 
            <see cref="M:Configit.Core.Capabilities.NddSolutionEnumeration.GetSingletonSolution(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},Configit.Core.Capabilities.NddEnumerationData)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.RespectAssignment(System.Int32,System.Int32)">
            <summary>
            Return true if <paramref name="value"/> respect given assignments to <paramref name="variable"/>
            (always true if <paramref name="variable"/> has no assignments )
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.MarkNodeAsInvalid(System.Int32,System.Int32)">
            <summary>
            Remember that specified node has no valid path to true terminal which satisfies
            the assignments
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.MarkNodeAsVisited(System.Int32,System.Int32)">
            <summary>
            Remember that node has been visited before
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddEnumerationData.CprForFreeVariable(System.Int32)">
            <summary>
            Get representation for free variable. Representation will ensure to respect any assignments
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.NddExtensions">
            <summary>
            Extension methods allowing to turn a <see cref="T:Configit.Core.Noddy.Bdd"/> in an <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> and to
            get the <see cref="N:Configit.Core.Noddy"/> instance for an <see cref="T:Configit.Core.Structure.Ndd.Ndd"/>. Also, support
            outputting an NDD to Graphviz format.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.ToDynamicNdd(Configit.Core.Structure.Ndd.Ndd)">
            <summary>
            Get <see cref="T:Configit.Core.Structure.Ndd.DynamicNdd"/> representing the same solution space as this <paramref name="ndd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.ToBdd(Configit.Core.Structure.Ndd.Ndd,Configit.Core.Noddy.Noddy)">
            <summary>
            Get <see cref="T:Configit.Core.Noddy.Bdd"/> representing the same solution space as this NDD. NDDs are
            converted to BDDs to be able to change the solution space by eg. applying additional
            constraints to the resulting BDD.
            If a <paramref name="noddy"/> instance is provided, the definition of the <see cref="P:Configit.Core.Noddy.Noddy.FdVars"/>
            is validated against the <see cref="P:Configit.Core.Structure.Ndd.Ndd.Variables"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.ToSolutionGraph(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Configit.Core.Model.ValueDefinitions.IValue}})">
            <summary>
            <para>Convert <paramref name="ndd"/> to a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionGraph"/> representing the same
            solution space as the NDD.</para>
            <para>Note that the sequence of the passed
            <paramref name="modelVariables"/> must match the variable indices used by the
            NDD. Private variables should e.g. not be passed in unless the <paramref name="ndd"/>
            also represents private variables.</para>
            </summary>
            <param name="ndd"><see cref="T:Configit.Core.Structure.Ndd.Ndd"/> to convert</param>
            <param name="multiValuedGroups">Definition of multi valued groups</param>
            <param name="domainFilters">Optional filters used to trim the valid domains of number and date-time variables.
            The domains in the resulting <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionSpace"/> will for each filtered variable in
            each solution represent the intersection of the valid domain and the given filter. If
            a number variable is e.g. assigned interval [1;3] and the valid domain for the number variable in
            a given solution is [-10;20] (given that is how the domains are "cut" by the rules), the resulting valid
            domain in the solution space will be [1;3]. Note: if any solution for any filtered variable is
            disjoined with the filter (the intersection of the filter and the original valid domain is empty), then
            an <see cref="T:System.ArgumentException"/> is thrown.</param>
            <param name="modelVariables">Variable used by <paramref name="ndd"/> (sequence must match the NDD)</param>
            <exception cref="T:System.ArgumentException">If <paramref name="ndd"/> is null or if
            <paramref name="modelVariables"/> does not match the
            definition of the used variables in the NDD.</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.ToSolutionCpr(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Configit.Core.Model.ValueDefinitions.IValue}})">
            <summary>
            <para>Convert <paramref name="ndd"/> to a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionCpr"/> representing the same
            solution space as the NDD.</para>
            <para>Note that the sequence of the passed
            <paramref name="modelVariables"/> must match the variable indices used by the
            NDD. Private variables should e.g. not be passed in unless the <paramref name="ndd"/>
            also represents private variables.</para>
            </summary>
            <exception cref="T:System.ArgumentException">If <paramref name="ndd"/> is null or if
            <paramref name="modelVariables"/> does not match the
            definition of the used variables in the NDD.</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.ToSolutionEnumeration(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Model.IReadonlyMultiValuedGroupSet,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{Configit.Core.Model.ValueDefinitions.IValue}})">
            <summary>
            <para>Convert <paramref name="ndd"/> to a <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionEnumeration"/> representing the same
            solution space as the NDD.</para>
            <para>Note that the sequence of the passed
            <paramref name="modelVariables"/> must match the variable indices used by the
            NDD. Private variables should e.g. not be passed in unless the <paramref name="ndd"/>
            also represents private variables.</para>
            </summary>
            <exception cref="T:System.ArgumentException">If <paramref name="ndd"/> is null or if <paramref name="modelVariables"/> does not match the
            definition of the used variables in the NDD.</exception>
            <exception cref="T:Configit.Core.Capabilities.Converters.EnumerationConversionException"> if solution space contains any solution where
            a string variable can accept any value</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.GetNoddy(Configit.Core.Structure.Ndd.Ndd,System.Int32)">
            <summary>
            Creates a new <see cref="N:Configit.Core.Noddy"/> instance that has finite domains matching
            those of the NDD.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.PrintAsDot(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Structure.Ndd.NddDotOptions)">
            <summary>
            Print the Ndd in Graphviz format as a directed graph. Output as string.
            If <paramref name="variables"/> is specified, the graph
            will not include NDD node numbers and value indices, but will print the variable names
            and value text representation. Note that the <see cref="P:Configit.Core.Structure.Ndd.Ndd.VariableDomains"/> all
            <see cref="P:Configit.Core.Structure.Ndd.Ndd.UsedVariables"/> in the NDD must match the variable domains of
            <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.PrintAsDot(Configit.Core.Structure.Ndd.Ndd,System.String,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Structure.Ndd.NddDotOptions)">
            <summary>
            Print the Ndd in Graphviz format as a directed graph. Output to
            specified file. If <paramref name="variables"/> is specified, the graph
            will not include NDD node numbers and value indices, but will print the variable names
            and value text representation. Note that the <see cref="P:Configit.Core.Structure.Ndd.Ndd.VariableDomains"/> all
            <see cref="P:Configit.Core.Structure.Ndd.Ndd.UsedVariables"/> in the NDD must match the variable domains of
            <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.PrintAsDot(Configit.Core.Structure.Ndd.Ndd,System.IO.TextWriter,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition},Configit.Core.Structure.Ndd.NddDotOptions)">
            <summary>
            Print the NDD in Graphviz format as a directed graph. Output to
            specified stream. If <paramref name="variables"/> is specified, the graph
            will not include NDD node numbers and value indices, but will print the variable names
            and value text representation. Note that the <see cref="P:Configit.Core.Structure.Ndd.Ndd.VariableDomains"/> all
            <see cref="P:Configit.Core.Structure.Ndd.Ndd.UsedVariables"/> in the NDD must match the variable domains of
            <paramref name="variables"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddExtensions.ValidateVariables(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Validate if <paramref name="variables"/> have domains that matches that
            of the <see cref="P:Configit.Core.Structure.Ndd.Ndd.UsedVariables"/> of the Ndd. It is accepted to have more
            entries in <paramref name="variables"/> that there are variables in the <paramref name="ndd"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If <paramref name="variables"/> does not match the used variables in the NDD.</exception>
        </member>
        <member name="T:Configit.Core.Capabilities.NddSolutionEnumeration">
            <summary>
            Extension methods allowing an to enumerate over solutions in an <see cref="T:Configit.Core.Structure.Ndd.Ndd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.ToTable(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},Configit.Core.Capabilities.NddEnumerationData)">
            <summary>
            <para>Get a tabular representation of solutions space represented by this
            NDD. The table is represented as collection of rows, each containing
            a collection of cells with a single value in each cell.</para>
            </summary>
            <remarks>The results are only guaranteed to be distinct (without duplicates)
            if all variables up until the highest variable in <paramref name="variablesToInclude"/>
            are marked as used in the NDD. Example: if <paramref name="ndd"/> contains 7
            variables, the highest variable in <paramref name="variablesToInclude"/>
            is 3 and variables 0, 1, 2, 3 are marked with <see cref="P:Configit.Core.Structure.Ndd.NddTable.NddVariable.UsedMark"/>
            then the output is guaranteed to be distinct.
            </remarks>
            <remarks>Notice that each of the rows returned in the resulting table contains
            a cell for each of the variables specified in <paramref name="variablesToInclude"/>.
            However, the result always contains cells for variables in sorted sequence. If
            <paramref name="variablesToInclude"/> is e.g. given as {0,7,2} each
            row in the result will contain values for variables in sequence {0,2,7}</remarks>
            <returns>All solutions satisfying the given <paramref name="assignments"/>, or the
            empty collection if no solutions exist.</returns>
            <param name="ndd"><see cref="T:Configit.Core.Structure.Ndd.Ndd"/> to get solutions for</param>
            <param name="variablesToInclude">Optional collection variables that should
            be represented in result. If this collection is null, all variables will
            be represented in output. If this collection is not null, only variables in this
            collection will be represented.</param>
            <param name="assignments">Optional collection of assignments, used to filter the result.
            Multiple assignments to the same variable is considered a disjunction.</param>
            <param name="data">Optional data element used for house-keeping while traversing the <paramref name="ndd"/>.
            If the <paramref name="ndd"/> is traversed multiple times, data can be re-used across these
            calls to prevent reallocation (re-use of data objects is done purely for
            performance reasons, it has no effect on the end result).</param>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.GetSingletonSolution(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},Configit.Core.Capabilities.NddEnumerationData)">
            <summary>
            <para>
            Get value in singleton solution space for <paramref name="variablesToInclude"/> which respects
            the given <paramref name="assignments"/>. A singleton solution space is a solution
            space containing exactly one solution for the specified variables. The returned
            value represents this single valid solution.
            </para>
            <para>If only a single solution is required, calling this method would typically be
            faster than calling <see cref="M:Configit.Core.Capabilities.NddSolutionEnumeration.ToTable(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},Configit.Core.Capabilities.NddEnumerationData)"/> (or <see cref="M:Configit.Core.Capabilities.NddSolutionEnumeration.ToCpr(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Boolean,Configit.Core.Capabilities.NddEnumerationData)"/>) followed by a
            test that there is only a single solution available.</para>
            </summary>
            <remarks>If only some variables are included in the result, then unlike
            <see cref="M:Configit.Core.Capabilities.NddSolutionEnumeration.ToCpr(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Boolean,Configit.Core.Capabilities.NddEnumerationData)"/> and <see cref="M:Configit.Core.Capabilities.NddSolutionEnumeration.ToTable(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},Configit.Core.Capabilities.NddEnumerationData)"/> this method
            ensures that duplicates are identified, effectively behaving like
            the results were made distinct before returning the singleton solution.
            </remarks>
            <remarks>Notice that the result contains one value
            for each of the variables specified in <paramref name="variablesToInclude"/>.
            However, the result always contains values for variables in sorted sequence. If
            <paramref name="variablesToInclude"/> is e.g. given as {0,7,2} the
            result will contain values for variables in the sequence {0,2,7}</remarks>
            <param name="ndd"><see cref="T:Configit.Core.Structure.Ndd.Ndd"/> to get solution for</param>
            <param name="variablesToInclude">Optional collection variables that should
            be represented in result. If this collection is null, all variables will
            be represented in output. If this collection is not null, only variables in this
            collection will be represented.</param>
            <param name="assignments">Optional collection of assignments, used to filter the result.
            Multiple assignments to the same variable is considered a disjunction.</param>
            <param name="data">Optional data element used for house-keeping while traversing the <paramref name="ndd"/>.
            If the <paramref name="ndd"/> is traversed multiple times, data can be re-used across these
            calls to prevent reallocation (re-use of data objects is done purely for
            performance reasons, it has no effect on the end result).</param>
            <returns>Single solution to <paramref name="variablesToInclude"/> satisfying
            <paramref name="assignments"/>or null if zero or
            more than one solution exists.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.SingletonSolution(Configit.Core.Capabilities.NddEnumerationData,System.Collections.Generic.List{System.Int32},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Forward search for finding singleton solution. If we are not 
            <paramref name="onSinglePath"/>, then we start marking nodes to
            avoid re-visiting and re-calculating the same results multiple
            times.
            </summary>
            <returns>True: Singleton path, False: no path, null: multiple solutions</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.SingletonValueForFreeVariable(Configit.Core.Capabilities.NddEnumerationData,System.Int32)">
            <summary>
            Get singleton value for variable, or -1 if no singleton exist
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.ToCpr(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},System.Boolean,Configit.Core.Capabilities.NddEnumerationData)">
            <summary>
            <para>Get Cartesian product representation (CPR) of solutions space represented by <paramref name="ndd"/>.
            The CPR is represented as a table where each cell might contain multiple
            values.</para>
            <para>The CPR can thus be read as a set of rows (first IEnumerable) containing
            a set of columns (second IEnumerable) where each cell might contain multiple values
            (third IEnumerable) for the variable represented by the column.</para>
            </summary>
            <remarks>The results are only guaranteed to be distinct (without duplicates)
            if all variables up until the highest variable in <paramref name="variablesToInclude"/>
            are marked as used in the NDD. Example: if <paramref name="ndd"/> contains 7
            variables, the highest variable in <paramref name="variablesToInclude"/>
            is 3 and variables 0, 1, 2, 3 are marked with <see cref="P:Configit.Core.Structure.Ndd.NddTable.NddVariable.UsedMark"/>
            then the output is guaranteed to be distinct.
            </remarks>
            <returns><para>All solutions satisfying the given <paramref name="assignments"/>, or the
            empty collection if no solutions exist.</para></returns>
            <remarks>Notice that each of the rows returned in the resulting CPR contains
            a cell for each of the variables specified in <paramref name="variablesToInclude"/>.
            However, the result always contains cells for variables in sorted sequence. If
            <paramref name="variablesToInclude"/> is e.g. given as {0,7,2} each
            row in the result will contain cells for variables in sequence {0,2,7}</remarks>
            <param name="ndd"><see cref="T:Configit.Core.Structure.Ndd.Ndd"/> to get solutions for</param>
            <param name="useNullForWildcard">If true, will insert a null element as cell
            representation when all values are allowed (instead of a more verbose full enumeration
            of all values in the domain of the variable)</param>
            <param name="variablesToInclude">Optional collection variables that should
            be represented in result. If this collection is null, all variables will
            be represented in output. If this collection is not null, only variables in this
            collection will be represented.</param>
            <param name="assignments">Optional collection of assignments, used to filter the result.
            Multiple assignments to the same variable is considered a disjunction.</param>
            <param name="data">Optional data element used for house-keeping while traversing the <paramref name="ndd"/>.
            If the <paramref name="ndd"/> is traversed multiple times, data can be re-used across these
            calls to prevent reallocation (re-use of data objects is done purely for
            performance reasons, it has no effect on the end result).</param>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.BuildCpr(System.Int32,System.Int32,System.Boolean,Configit.Core.Capabilities.NddEnumerationData)">
            <summary>
            <para>The algorithm uses a marker for nodes. When it finds a node for which it knows there
            is no valid path to true terminal (due to assignments), it marks the node. It tries to
            be lazy by avoiding doing any kind of marking until absolutely required. It uses the fact
            that it is a search algorithm, so it will only mark nodes that it visits in its search.
            </para>
            <para>
            Result is generated by the following three steps
            <list type="bullet">
            <item>
            Phase 1 does a top down search guided by assignments. As soon we reach a node
            with more than one possible child, we switch to phase 2 (in other words: follows
            a single path as far as possible). If we reach the last included variable in this phase,
            we have found the (only available) answer. Before returning the answer, we use
            forward scan to see if we can find any valid path to the terminal which satisfies the assignments.
            If such path does not exist, the answer we found is invalid. We mark invalid nodes during
            forward scan, as to avoid full path enumeration.
            </item>
            <item>
            Preparing for phase 2, we might have to do some node marking in cases where
            phase 1 did not find the answer we were looking for, and when
            there are assignments to variables larger than the last variable included in the
            result. In this case we mark the nodes so we can trust node marks on the layers below
            the last included variable. We only need to mark layers between last included variable
            and last assigned variable.
            </item>
            <item>Phase 2 enumerates all paths downwards from node found in phase 1. Enumeration stops
            when we get to the layer representing last variable to include in result. Given
            the previous step (where we mark nodes below the last included variable), we
            know we can trust the node marks to tell us if there is a valid path from
            here and down to the terminal which satisfies the assignments.
            </item>
            </list>
            </para>
            <paramref name="onSinglePath"/> being true means we are in phase 1 of the algorithm.
            </summary>
            <returns>Returns the empty collection, if the assignment cannot be satisfied</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.HasValidPathFromNode(System.Int32,System.Int32,Configit.Core.Capabilities.NddEnumerationData)">
            <summary>
            Back-track search, which goes from node and downwards, trying to find
            a path to the true terminal. Returns true if successful
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.NddSolutionEnumeration.PrepareForPhaseTwo(Configit.Core.Capabilities.NddEnumerationData,System.Int32)">
            <summary>
            Mark nodes bottom-up, so we can trust the node marks when we get to phase two (for both CPR and singleton)
            We mark all nodes in layers from last assigned variable to <paramref name="lastLayerToMark"/>
            Return an indication if some assignments cannot be satisfied - in this case, it bails out
            early, and stop marking nodes (stops when a given layer has no valid nodes)
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.PackagedModelExtensions">
            <summary>
            Extension methods for <see cref="T:Configit.Core.Model.PackagedModel"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.PackagedModelExtensions.GetCapabilities``1(Configit.Core.Model.PackagedModel)">
            <summary>
            Returns all <see cref="T:Configit.Core.Model.ICompiledCapability"/> instances of type <typeparamref name="TCapability"/> 
            that can be created from any of the <see cref="T:Configit.Core.Model.ICompiledData"/> in the <see cref="T:Configit.Core.Model.PackagedModel"/>
            using the standard <see cref="T:Configit.Core.Capabilities.CompiledCapabilityFactory"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.PackagedModelExtensions.GetCapability``1(Configit.Core.Model.PackagedModel)">
            <summary>
            Get first <see cref="T:Configit.Core.Model.ICompiledCapability"/> instance of type <typeparamref name="TCapability"/> 
            that can be created from any of the <see cref="T:Configit.Core.Model.ICompiledData"/> in the <see cref="T:Configit.Core.Model.PackagedModel"/>
            <returns>First instance that can be created, or null if no instance can be created</returns>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup">
            <summary>
            Represents blocked values for a specific part of the solution space as indicated by
            <see cref="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.Group"/>.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.Group">
            <summary>
            Possibly empty set of single valued assignments, for which the <see cref="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.BlockedValues"/> apply.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.BlockedValues">
            <summary>
            The values that are blocked given the assignments in <see cref="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.Group"/>. 
            Contains an entry for each variable provided to <see cref="M:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.GetBlockedValuesByGroup(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.FdValues},Configit.Core.Noddy.Bdd,System.Int32)"/>. 
            If variable has no blocked values, an entry with the empty value collection is provided.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor">
            <summary>
            Interface for query processors. Allows efficient generic queries that fall outside what can be supplied from a configurator. 
            A simple example is to obtain a projection of the solution space, or to check for satisfiability.
            The query processor maintains a cache to optimize the execution of operations over the same subset of variables.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor.GetBlockedValues(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Find values that are blocked in the specified finite domain variables.
            <param name="batchSize">
            Optionally specifies how many variables to compute blocked values for at a time.
            </param>
            <param name="variables">The variables to determine blocked values for. This parameter
            determines which variables are included in the <see cref="T:Configit.Core.Noddy.FdValuesCollection"/> in the result.
            If variables is not specified, all variables will be processed. If an empty list of variables is explicitly
            provided then all returned groups are empty</param>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor.GetBlockedValuesByGroup(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.FdValues},Configit.Core.Noddy.Bdd,System.Int32)">
            <summary>
            <para>
            Get blocked values for all <paramref name="variables"/>. The entries in 
            the result represent the blocked values found when applying a set of 
            assignments to the <paramref name="groupingVariables"/>.
            </para>
            <para> 
            The result contains as many groups as there are valid value assignments to 
            the <paramref name="groupingVariables"/>, given the underlying <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/>
            conjoined with <paramref name="groupRestriction"/>. If no <paramref name="groupingVariables"/>
            are provided, a single entry is returned.
            </para>
            <para>Each entry only contains blocked values which are included in the <paramref name="valueFilter"/>. 
            If no <paramref name="valueFilter"/> is specified, all blocked values in <paramref name="variables"/>
            are included.</para>
            <para>The <paramref name="variables"/> and the <paramref name="groupingVariables"/> must 
            be disjoint.</para>
            </summary>
            <param name="variables">The variables to determine blocked values for. This parameter
            determines which variables are included in the generated <see cref="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.BlockedValues"/>.
            If a list of variables is not specified, all variables will be processed. If an empty list of variables is explicitly
            provided then all <see cref="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.BlockedValues"/> are empty</param>
            <param name="groupingVariables">Variables used to determine available value permutations
            in the returned <see cref="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.Group"/>. Each combination of the grouping 
            variables that are valid according to the conjunction of the underlying <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/> with
            <paramref name="groupRestriction"/> is represented as a group in the result. If no 
            grouping variables are specified, the result contains a single group with an empty key</param>
            <param name="valueFilter">For variables mentioned in the <paramref name="valueFilter"/>, 
            only values in the filter will be reported as blocked values
            in the resulting <see cref="T:Configit.Core.Noddy.FdValues"/>. If no filter is provided, all blocked values in 
            <paramref name="variables"/> are reported. All variables mentioned in the filter must be included
            in the <paramref name="variables"/>. If a filter is used, and the filter does not mention a 
            specific variable, all blocked values for this variable will be included in the result.</param>
            <param name="groupRestriction">Restricts the results such that only permutations of the 
            <paramref name="groupingVariables"/> that are valid according to the conjunction of the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/>
            and the group restriction are included in the result. If no group restriction is provided,
            all permutations allowed by the underlying <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/> are included. The <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/>
            of the group restriction must be a subset of the <paramref name="groupingVariables"/></param>
            <param name="batchSize">
            Optionally specifies how many variables to compute blocked values for at a time.</param>
            <returns>Blocked values for <paramref name="variables"/>, grouped by valid combinations
            of <paramref name="groupingVariables"/>. The <see cref="P:Configit.Core.Capabilities.QueryProcessing.BlockedValuesByGroup.BlockedValues"/>
            contains an entry for each variable in <paramref name="variables"/> - if a variable does not
            have any blocked values, the empty value set is provided.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor.Project(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Obtains a BDD representing the projection of the solutions of the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/> onto the
            supplied <paramref name="targetFdVars"/>.
            </summary>
            <param name="targetFdVars">Variable to project onto</param>
            <param name="constraints">Optional additional constraints to apply</param>
            <returns>A single BDD representing the projection</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor.Satisfy(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Similar to <see cref="M:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor.Satisfy(Configit.Core.Noddy.Bdd,System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>, but intended for processing a batch of
            BDDs with similar support. For example, in BOM validation we might be validating
            a group of statements with the same or almost the same support set.
            </summary>
            <param name="bdds">BDDs to be validated against the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/></param>
            <param name="constraints">Specifies a restriction to apply to the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/></param>
            <returns>An array with a BDD for each input BDD, such that it either 
            contains at least one solution that is valid on combination with the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/>
            or is false</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor.Satisfy(Configit.Core.Noddy.Bdd,System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Attempts to find a solution that satisfies the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/> 
            </summary>
            <remarks>
            The purpose of calling this method over <see cref="M:Configit.Core.Noddy.Noddy.Satisfy(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)"/>
            is that the query processor can utilize its cache to speed up the response.
            </remarks>
            <param name="bdd">The BDD to validate against the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/></param>
            <param name="constraints">Specifies a restriction to apply to the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/></param>
            <returns>A BDD representing a solution or false if no solutions exist</returns>
        </member>
        <member name="P:Configit.Core.Capabilities.QueryProcessing.IQueryProcessor.Noddy">
            <summary>
            The <see cref="T:Configit.Core.Noddy.Noddy"/> instance associated with the internal BDDs.
            Results from operations will use this instance.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.QueryProcessing.NamespaceDoc">
            <summary>
            Capability that supports processing general queries against a
            solution space.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.QueryProcessing.ProjectCacheKey">
            <summary>
            Key for caching projections on certain variables (under certain constraints) in <see cref="T:Configit.Core.Capabilities.QueryProcessing.QueryProcessor"/>.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.QueryProcessing.QueryProcessor">
            <summary>
            Allows efficient generic queries that fall outside what can be supplied from a configurator. 
            A simple example is to obtain a projection of the solution space, or to check for satisfiability.
            The query processor maintains a cache to optimize the execution of operations over the same subset of variables.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds">
            <summary>
            The compiled <see cref="T:Configit.Core.Noddy.Bdd"/>s representing the solutions space we query against. All query 
            operations work logically against the conjunction of these BDDs. 
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.Noddy">
            <summary>
            The <see cref="T:Configit.Core.Noddy.Noddy"/> instance associated with the <see cref="P:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.QueryBdds"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.QueryProcessorData)">
            <summary>
            Create a query processor for for a specific set of preprocessed data.
            TODO: Allow passing in cache size parameters
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.Project(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.Satisfy(Configit.Core.Noddy.Bdd,System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.Satisfy(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.GetBlockedValues(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.QueryProcessing.QueryProcessor.GetBlockedValuesByGroup(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.FdValues},Configit.Core.Noddy.Bdd,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.SolutionGraphExtensions">
            <summary>
            Extensions to <see cref="T:Configit.Core.Structure.SolutionSpace.SolutionGraph"/> used e.g. for outputting to Graphviz format
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.SolutionGraphExtensions.PrintAsDot(Configit.Core.Structure.SolutionSpace.SolutionGraph,System.String)">
            <summary>
            Print the solution graph in Graphviz format as a directed graph. Output to
            specified file. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.SolutionGraphExtensions.PrintAsDot(Configit.Core.Structure.SolutionSpace.SolutionGraph,System.String,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Print the solution graph in expanded tree format, without shared nodes, and with only
            a single value per node. Output to specified file. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.SolutionGraphExtensions.PrintAsDot(Configit.Core.Structure.SolutionSpace.SolutionGraph,System.IO.TextWriter,Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Print the solution graph in expanded tree format, without shared nodes, and with only
            a single value per node
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.SolutionGraphExtensions.PrintAsDot(Configit.Core.Structure.SolutionSpace.SolutionGraph,System.IO.TextWriter)">
            <summary>
            Print the solution graph in Graphviz format as a directed graph. Output to
            specified writer. 
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.TypeConverter`3">
            <summary>
            Creates new objects of type (or sub-type of) <typeparamref name="TTarget"/> from <typeparamref name="TSource"/> (or sub-types) based
            on registered type mappings.
            </summary>
            <typeparam name="TSource">
            The type of object provided as source for the conversion
            </typeparam>
            <typeparam name="TParam">
            The type of data passed to the constructor function.
            </typeparam>
            <typeparam name="TTarget">
            The resulting output type
            </typeparam>
        </member>
        <member name="F:Configit.Core.Capabilities.TypeConverter`3._converterMap">
            <summary>
            Maps from source type to instance creator function.
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.TypeConverter`3._typeMap">
            <summary>
            Maps from the source type to the target type type.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.TypeConverter`3.RegisterConversion``2(System.Func{``0,`1,``1})">
            <summary>
            Registers a conversion from from <typeparamref name="TInput"/> to <typeparamref name="TOutput"/>. 
            <typeparamref name="TOutput"/> must define a constructor taking a parameter of type <typeparamref name="TInput"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.TypeConverter`3.Create``1(`0,`1)">
            <summary>
            Selects the matching mapping registered through <see cref="M:Configit.Core.Capabilities.TypeConverter`3.RegisterConversion``2(System.Func{``0,`1,``1})"/> and uses that to
            create a new object which is returned with a cast to the requested output type.
            </summary>
            <typeparam name="TOutput">The out type requested, which must be a subtype of <typeparamref name="TTarget"/></typeparam>
            <param name="input">The object to be converted</param>
            <param name="param">Constructor parameter</param>
            <exception cref="T:System.ArithmeticException">If no type mapping is setup for the input type.</exception>
        </member>
        <member name="M:Configit.Core.Capabilities.TypeConverter`3.Create``1(System.Collections.Generic.IEnumerable{`0},`1,System.Predicate{`0})">
            <summary>
            Finds the <typeparamref name="TSource"/> that can support the requested 
            <typeparamref name="TOutput"/> and creates an instance for them. If no <typeparamref name="TSource"/> supports
            the requested type.
            </summary>
            <typeparam name="TOutput">The type of <see cref="!:ICompiledCapability"/> to create</typeparam>
            <param name="sourceData">The list of <typeparamref name="TSource"/> to search</param>
            <param name="param">Constructor parameter type</param>
            <param name="filter">Optional predicate for filtering source data</param>
        </member>
        <member name="T:Configit.Core.Capabilities.UserAssignment">
            <summary>
            <para>Represents a disjoined assignment to a specific variable. Representing
            variables and values as indices</para>
            <para>Variable indices can represent both public and model variable indices - this
            depends on the context in which it is used. Use 
            <see cref="M:Configit.Core.Capabilities.UserAssignmentExtensions.AssignToModelVariable(Configit.Core.Capabilities.UserAssignment,Configit.Core.Model.VariableCatalog)"/> to transform from public 
            variable index to model variable index.</para>
            <para>The <see cref="P:Configit.Core.Capabilities.UserAssignment.IsInterval"/> indicates if the assignment represents 
            an interval from some lower value (in index 0) to some upper value (in index 1)
            </para>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.#ctor(System.Int32,System.Int32,System.Object)">
            <summary>
            Create an user assignment representing the specified value assigned to the
            specified public variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Create a user assignment representing a disjunction of values assigned to the 
            specified public variable
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.#ctor(System.Int32,System.Int32,System.Int32,System.Object,System.Object)">
            <summary>
            Create a user assignment representing the assignment of an interval to the
            specified public variable
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.UserAssignment.Variable">
            <summary>
            IL index of variable. Variable represent a public variable
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.UserAssignment.IsInterval">
            <summary>
            Indication if assignment is to be considered an interval. In this case, the
            <see cref="P:Configit.Core.Capabilities.UserAssignment.ValueIndices"/> will contain exactly 2 elements - the lower and the 
            upper bound of the interval.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.UserAssignment.ValueIndices">
            <summary>
            IL index of values
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.UserAssignment.Values">
            <summary>
            Actual values assigned.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.UserAssignment.Count">
            <summary>
            Number of values in assignment. If more than 1, the values are disjointly 
            assigned
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.GetValue(System.Int32)">
            <summary>
            Returns the finite domain value stored in the input assignment given an index into the values in the assignment
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.GetValueIndex(System.Int32)">
            <summary>
            Returns the finite domain value index given an index into the values in the assignment
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.Equals(Configit.Core.Capabilities.UserAssignment)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignment.ToString">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.UserAssignmentExtensions">
            <summary>
            Extensions allowing operations on <see cref="T:Configit.Core.Capabilities.UserAssignment"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignmentExtensions.AssignToModelVariable(Configit.Core.Capabilities.UserAssignment,Configit.Core.Model.VariableCatalog)">
            <summary>
            Given a <see cref="T:Configit.Core.Capabilities.UserAssignment"/> to a public variable, get the corresponding 
            assignment to the model variable
            </summary>
            <param name="publicVariableAssignment">Assignment in public variable space</param>
            <param name="variableCatalog">Mapping from public to model variable space</param>
            <returns></returns>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignmentExtensions.ToBdd(System.Collections.Generic.IEnumerable{Configit.Core.Capabilities.UserAssignment},Configit.Core.Noddy.Noddy)">
            <summary>
            Given a collection of <see cref="T:Configit.Core.Capabilities.UserAssignment"/> objects representing
            assignment to variables which index matches the given <paramref name="noddy"/> instance,
            create a <see cref="T:Configit.Core.Noddy.Bdd"/> representing  the semantics of the assignments to model variables.
            </summary>
            <param name="assignments">Assignments to create BDD for</param>
            <param name="noddy"><see cref="N:Configit.Core.Noddy"/>instance to create BDD for. Variables instantiated in this instance
            must match the model variables in the <paramref name="assignments"/></param>
            <returns><see cref="T:Configit.Core.Noddy.Bdd"/> representing the conjunction of all assignments (notice that 
            each assignment might represent a disjunction), or <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/>
            if <paramref name="assignments"/> is null or contains no elements.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignmentExtensions.ToBdd(Configit.Core.Capabilities.UserAssignment,Configit.Core.Noddy.Noddy)">
            <summary>
            Turn a single <see cref="T:Configit.Core.Capabilities.UserAssignment"/> into a <see cref="T:Configit.Core.Noddy.Bdd"/>. The variable index of
            the <see cref="P:Configit.Core.Capabilities.UserAssignment.Variable"/> must match the finite domain variables in the 
            <paramref name="noddy"/> instance.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.UserAssignmentExtensions.ToUserAssignments(System.Collections.Generic.IEnumerable{Configit.Core.Model.VariableDefinitions.Assignment},Configit.Core.Model.IReadOnlyIdentifyableEntityList{Configit.Core.Model.VariableDefinitions.IVariableDefinition})">
            <summary>
            Convert collection of <see cref="T:Configit.Core.Model.VariableDefinitions.Assignment"/> objects to a collection of <see cref="T:Configit.Core.Capabilities.UserAssignment"/>.
            The <paramref name="modelVariables"/> is used to map from <see cref="P:Configit.Core.Model.VariableDefinitions.Assignment.VariableId"/>
            to variable index.
            </summary>
            <returns>Collection of <see cref="T:Configit.Core.Capabilities.UserAssignment"/> representing the same as <paramref name="assignments"/>
            but using variable indices, or null if <paramref name="assignments"/> is null.</returns>
        </member>
        <member name="T:Configit.Core.Capabilities.Utilities.ICacheContainer">
            <summary>
            Interface for a container of caches, used to allow
            capabilities to store caches alongside for example solve data
            <remarks>The container is guaranteed to be thread-safe.</remarks>
             </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.ICacheContainer.GetCache``1(System.Guid,System.Func{``0})">
            <summary>
            Gets or creates a specific cache.
            </summary>
            <param name="guid">Unique identifier for the cache.</param>
            <param name="createCache">Callback for creating the cache if it doesn't exist.</param>
            <typeparam name="T">Cache type</typeparam>
        </member>
        <member name="T:Configit.Core.Capabilities.Utilities.NddEnumerationDataPool">
            <summary>
            Pool of <see cref="T:Configit.Core.Capabilities.NddEnumerationData"/> objects used in <see cref="T:Configit.Core.Capabilities.NddSolutionEnumeration"/>. Each thread
            must operate on its data object. Running multi-threaded, this pool provides
            a mechanism for re-using dat objects across multiple threads.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.NddEnumerationDataPool.#ctor(Configit.Core.Structure.Ndd.Ndd)">
            <summary>
            Initialize with ndd to create data objects for.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.NddEnumerationDataPool.CreateItem">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.NddEnumerationDataPool.PrepareItem(Configit.Core.Capabilities.Disposable{Configit.Core.Capabilities.NddEnumerationData})">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.Utilities.ValidDomainRequestResponse">
            <summary>
            <para>Object holding corresponding <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/> and
            <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/> objects used for the same
            <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>.</para>
            <para>This is used in caching context such as <see cref="T:Configit.Core.Capabilities.Utilities.ValidDomainSolveRequestResponsePool"/></para>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.ValidDomainRequestResponse.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <summary>
            Create pair of request / response objects that belong to the same <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Utilities.ValidDomainRequestResponse.Request">
            <summary>
            Request object that can be used in combination with <see cref="P:Configit.Core.Capabilities.Utilities.ValidDomainRequestResponse.Response"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.Utilities.ValidDomainRequestResponse.Response">
            <summary>
            Response object that can be used in combination with <see cref="P:Configit.Core.Capabilities.Utilities.ValidDomainRequestResponse.Request"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.Utilities.ValidDomainSolveRequestResponsePool">
            <summary>
            Pool of request/response objects used for a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>. Each thread
            must operate on its own request and response objects. Running multi-threaded, this pool provides
            a mechanism for re-using request-response objects across multiple threads.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.ValidDomainSolveRequestResponsePool.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver)">
            <summary>
            Create pool for <paramref name="solver"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.ValidDomainSolveRequestResponsePool.CreateItem">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.Utilities.ValidDomainSolveRequestResponsePool.PrepareItem(Configit.Core.Capabilities.Disposable{Configit.Core.Capabilities.Utilities.ValidDomainRequestResponse})">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest">
            <summary>
            <para>Base class for all solve requests. Provided for handling mapping from public variable indices
            to model variable indices, tracks basic addition and removal of assignments. Provided to allow
            <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> specific request instances to only handle state that actually
            belongs to the appropriate data structure for the domain solver.</para>
            <para>Specializations of this class will be responsible for handing data relevant for specific
            <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> implementations, while this base class handles
            all assignments, flags etc. set by the user.</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest.ModelVariables">
            <summary>
            Catalog of model variables
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest.GetPrioritisedAssignmentModelVariables(Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)">
            <summary>
            Priorities sequence of how variables are applied. Most important variables first.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest.VariableCatalog">
            <summary>
            Variable catalog defining both model and public variables, and the mapping
            between them
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest.Query">
            <summary>
            Container of all assignments, priority settings, completion flags etc.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData">
            <summary>
            Compiled data used for supporting solves based on a static <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData.Daog"/>, which allows 
            solves on very large models without requiring scope to be set first.
            <seealso cref="T:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData.#ctor(Configit.Core.Structure.Daog.Daog,System.String)">
            <summary>
            Create a new DAOG based solve data based on the specified DAOG.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData.Daog">
            <summary>
            The <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData.Daog"/> that defines the solution space
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData.Id">
            <summary>
            Identifier of entity
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData.TypeIdentifier">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.IValidDomainSolveData">
            <summary>
            A solve data is consumed by a matching <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.IValidDomainSolveData"/> at runtime.
            <seealso cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NamespaceDoc">
            <summary>
            Representation of data that has been compiled for a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>, allowing
            the solver to support configuration.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData">
            <summary>
            Represents the data to perform scoped valid domain solves where certain variables have to be fixed
            before the rest can be configured.
            <seealso cref="T:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.#ctor(Configit.Core.Structure.Ndd.Ndd,System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.FdValues},System.String)">
            <summary>
            Creates a JIT solve data.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.BlockedValues">
            <summary>
            Pre-computed blocked values for model variables
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.JitScopeVariables">
            <summary>
            JIT scope model variable indices. No inference can be made on non-jitscope variables before JIT scope has been fully defined.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.ScopeNdd">
            <summary>
            The NDD used to configure the scope. Variable ordered matches <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.BddsForJit"/> and the <see cref="P:Configit.Core.Model.PackagedModel.Variables"/>/>.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.BddsForJit">
            <summary>
            The processed BDDs used to perform at JIT compilation once the scope has been set.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.Id">
            <summary>
            Identifier of entity
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData.TypeIdentifier">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData">
            <summary>
            Data for the simple <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData.Ndd"/> based solver.
            <seealso cref="T:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver"/> 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData.#ctor(Configit.Core.Structure.Ndd.Ndd,System.String)">
            <summary>
            Create a new solve data build on specified <see cref="T:Configit.Core.Structure.Ndd.Ndd"/> table
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData.Ndd">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData.Ndd"/> structure representing semantics of model
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData.Id">
            <inheritdoc />
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData.TypeIdentifier">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.QueryProcessorData">
            <summary>
            Carries pre-processed data intended to allow efficient generic queries that fall outside what
            can be supplied from a configurator. A simple example is to obtain a projection of the solution space.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.QueryProcessorData.Id">
            <summary>
            Identifier of entity
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.QueryProcessorData.#ctor(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.String)">
            <summary>
            Create the data object with a set of pre-processed bdds.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.QueryProcessorData.QueryBdds">
            <summary>
            A set of pre-processed bdds that form the basis for queries.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.QueryProcessorData.TypeIdentifier">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest">
            <summary>
            Implementation of <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/> used in conjunction with <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver"/>.
            It contains color markings for DAOG nodes in order to allow multi-threaded access to the solver (and hence 
            the underlying <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.Daog"/>).
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest._nodeColors">
            <summary>
            Stores the node color by node index. Is masked to hold a mark
            in addition to the color.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.NodeDouble">
            <summary>
            A double valued cost per node that is used for optimizing by cost instead of priority.
            TODO: This could be used for both solution count and the completion optimization costs.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.EnsureNodeDoubles">
            <summary>
            Allocates <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.NodeDouble"/> if it hasn't been done already.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.EnsureSolutionCount">
            <summary>
            Allocates <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.SolutionCount"/> if it hasn't been done already.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.MaximizeNodeDouble">
            <summary>
            If set, the completion algorithm updates the node double instead of the ulong node cost.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.CostIsBitArray">
            <summary>
            Indicator used in <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ColorAnd(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)"/> to optimize
            how costs are combined. It is set to true when all priority groups
            being currently processed have cardinality 1.
            <remarks>
            This is only used in <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ValidateAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)"/>
            and is reset every time, so it is not reset by <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest.Reset"/>.
            </remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.Daog">
            <summary>
            The <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.Daog"/> that this solve request belongs to
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.ColorAllNodes(System.Byte)">
            <summary>
            Set all nodes to specified color
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.NodeColor(System.Int32)">
            <summary>
            Get color of node
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.ColorNode(System.Int32,System.Byte)">
            <summary>
            Set color of node, and clear any marks on node
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.IsNodeMarked(System.Int32)">
            <summary>
            True if node has been marked using <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.MarkNode(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.MarkNode(System.Int32)">
            <summary>
            Mark node. Get mark value using <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.IsNodeMarked(System.Int32)"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.SolutionCount">
            <summary>
            Cache of solution count for each node
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.PrintDaogAsDot(System.String)">
            <summary>
            Print <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.Daog"/> as dot with current node colors
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.NodeCost">
            <summary>
            The cost associated with each node, used
            for determining the optimal path during 
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ValidateAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)"/> and <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver"/> 
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.VariableCost">
            <summary>
            The cost associated with violating the assignment
            to a given (model) variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.ResetVariableCost">
            <summary>
            Resets the variable penalty array
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.ResetNodeCost">
            <summary>
            Resets the node penalty array
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest.ResetSolutionCount">
            <summary>
            Resets cached solution counts
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver">
            <summary>
            Domain solver that uses a <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Daog"/> to calculate unconstrained domains. 
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.DaogSolveData,Configit.Core.Model.VariableCatalog)">
            <summary>
            Create a <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Daog"/> based solver
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.SupportedFeatures">
            <summary>
            Supported features when using a <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Daog"/> for calculating valid domains
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.CreateRequest">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.CreateResponse">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <inheritdoc />
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.PublicVariables">
            <summary>
            Variable index containing all public variables (that is, all variables except the private 
            ones)
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.MostImportantBit">
            <summary>
            The most important bit in the node penalties is used
            to as cost for variables that have been verified 
            in previous batches.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ValidateAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)">
            <summary>
            Validates assignments, resolves any conflicts. Solve request is updated to only contain valid assignments.
            </summary>
            <returns>Indices of public variables with conflicting assignments that was removed</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.UpdateCosts(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.List{System.Int32})">
            <summary>
            Update penalties for variables in batch, updating conflicts along the way.
            Return true if recoloring is needed otherwise false.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.RemoveConflictingAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Follows optimal path through the DAOG, removing conflicting assignments.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.RemoveBlockedAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)">
            <summary>
            Run through assignment list, and prune assignments to blocked values (disjunction, where
            only a subset of the assignments are blocked are accepted). Return variables for which an
            assignment has been removed.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ColorNodes(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)">
            <summary>
            Color graph recursively according to assignments in request. Returns
            color of node
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ColorOr(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)">
            <summary>
            Color Or node in request
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ColorAnd(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)">
            <summary>
            Color And node in request
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.ColorTerminal(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)">
            <summary>
            Color Terminal node in request
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.MaxGroupsPerBatch">
            <summary>
            For testing purposes only (set via reflection). Used to
            force multiple phases in small test cases.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.AddCompletedAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32,System.Byte)">
            <summary>
            Follows the longest path tree adding assignments to the request.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.GetSolutionCount(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest)">
            <summary>
            Get number of solutions satisfying last applied assignments
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainSolver.UpdateUnconstrained(Configit.Core.Capabilities.ValidDomainSolvers.Daog.DaogValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)">
            <summary>
            Recursively traverse graph, finding unconstrained domain values
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.Daog.NamespaceDoc">
            <summary>
            Configuration capability that reads a static <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Daog"/> and is capable of configuration
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.IJitValidDomainSolver">
            <summary>
            Interface for JIT-based based domain solvers. JIT-based solvers
            requires a certain subset of the variables to be set before
            inference on the rest can be performed. These
            are exposed in <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IJitValidDomainSolver.JitScopeVariables"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IJitValidDomainSolver.JitScopeVariables">
            <summary>
            Public variables that must be specified for the JIT-based solver
            to provide full inference
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder">
            <summary>
            Represents the encoding of an array of unsigned integers packed into an <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder._bitMasks">
            <summary>
            The bit mask needed to mask out all but 
            one unsigned integer.
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder._shifts">
            <summary>
            The number of shifts to apply to decode
            an unsigned integer value.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.#ctor(System.Collections.Generic.IList{System.UInt32},System.Int32)">
            <summary>
            Creates an encoding capable of holding a number of unsigned integers 
            matching the length and maximum size indicated in <paramref name="maxValues"/>.
            </summary>
            <param name="maxValues">Maximum values that must be supported for each unsigned int.</param>
            <param name="prefixOffset">Number of most significant bits to leave unsigned in the encoding.</param>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.Create(System.UInt32[],System.Int32)">
            <summary>
            Creates a number of encoders sufficient to contain all the value sizes provided.
            </summary>
            <param name="maxValues">Maximum values that must be supported for each unsigned int</param>
            <param name="prefixOffset">Number of most significant bits to leave unsigned in each encoding.</param>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.Count">
            <summary>
            Number of unsigned integer held in the encoding.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.CreateBitMask(System.Int32@,System.UInt32)">
            <summary>
            Creates the bitmask that will include
            only bits for the integer start at bit <paramref name="pos"/>.
            </summary>
            <param name="pos">Next available bit</param>
            <param name="max">Maximum value for unsigned int.</param>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.GetBitsNeeded(System.UInt32)">
            <summary>
            Computes the number of bits required to store an
            unsigned int with max value <paramref name="max"/>.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.MaxBits">
            <summary>
            Returns max bits available for encoding.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.GetValue(System.Int32,System.UInt64)">
            <summary>
            Returns the value of the indexed number
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.SetValue(System.Int32,System.UInt64,System.UInt32)">
            <summary>
            Set the indexed number to the given value
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.GetValues(System.UInt64)">
            <summary>
            Returns the value of each encoded unsigned integer.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder.ToString(System.UInt64)">
            <summary>
            Returns a string indicating the value of each encoded uint.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest">
            <summary>
            <para>A valid domain request defines the query that is passed to a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> - the assignments
            and the assignment priorities. It is intended that all implementations of <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>
            uses a dedicated valid domain request and response type to store the internal data used
            to represent the consequence of assigning
            value in a solve state. </para>
            <para>Creation of a request object can be expensive, so it should be cached
            and re-used whenever possible. The <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.Reset"/> method is provided to make it easy to
            bring a previously used request object back to its original state (with no assignments
            and no assignment properties).</para>
            <para>All variable indices are public variable indices</para>
            <para>Operations on a solve request are not thread safe. Each thread should use its own
            dedicated <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/> instance.</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AddAssignment(System.Int32,System.Int32)">
            <summary>
            Add specific assignment to public variable as disjunctive assignment. To 
            ensure only a single assignment exist for the specified variable, call 
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.RemoveAssignments(System.Int32)"/> first.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.SetAssignment(System.Int32,System.Int32)">
            <summary>
            Remove any existing assignment to variable, and set defined <paramref name="value"/> as
            the only assigned value.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.RemoveAssignments(System.Int32)">
            <summary>
            Remove all assignments made to specified public variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.HasAssignment(System.Int32,System.Int32)">
            <summary>
            <para>
            Test if specific <paramref name="value"/> has been assigned to <paramref name="publicVariable"/>.
            Value might be a disjunctively assigned value. Assigned values are not changed during solve
            </para>
            <para>That a value is assigned does not mean that the assignment is valid. 
            Look at <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.GetUnconstrained(System.Int32,System.Int32)"/> and 
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.ConflictingVariables"/>to check if assigned value
            is valid.</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.HasAssignment(System.Int32)">
            <summary>
            Test if <paramref name="publicVariable"/> has any assignments. This is identical 
            to asking if any value in the domain of <paramref name="publicVariable"/>
            has <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.HasAssignment(System.Int32,System.Int32)"/> as true.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ResetAllAssignments">
            <summary>
            Remove all assignment to all public variables
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.Reset">
            <summary>
            Performs a complete reset of the domain request, ensuring that
            its content matches that of calling <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.CreateRequest"/>
            Compared to <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ResetAllAssignments"/>, this method also reset
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AssignmentSequence"/>, <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>,
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ComputeSolutionCount"/>, <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.Complete"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AssignmentSequence">
            <summary>
            <para>Sequence of public variable indices that controls order in which variable assignments 
            are applied. Variables first in list takes precedence over later variables.</para>
            <para>Set this property to null to reset the assignment sequence to the default sequence which depends on the solver in use.</para>
            <para>The sequence is given as a list of variable index collections. Variables in the same collection has the same order in the
            sequence, indicating that their internal ordering in the group is irrelevant.</para>
            <remarks>Sequenced variables that are not assigned are ignored</remarks>
            <example>Given { {2,3},{0,1} }, assignments to variables with indices 2 and 3 take precedence over variables 0 and 1, but the
            <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> is free to use its preferred sequence within each group. 
            I.e. if the assignments to 2 and 3 are in conflict, then no guarantee 
            is given as to which one will be reported as conflicting.</example>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.Complete">
            <summary>
            <para>
            Complete the configuration using the value priorities defined in <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>
            and <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionCosts"/>.
            </para>
            <para>
            Complete only attempts to assign a value to a variable if it does not already have a user assignment
            (disjoined or not). Values not considered for completion (<see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>)
            can still be inferred but they wont be user assigned.</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence">
            <summary>
            <para> 
            In global value ordering (see <see cref="M:Configit.Core.Model.VariableCollection.GetGlobalValueIndex(System.Int32,System.Int32)"/>) provides a sequence number for each value in the model
            (must be of length <see cref="P:Configit.Core.Model.VariableCollection.ValueCount"/>).
            A negative sequence indicate that the value should not be considered for completion, while lower positive sequence numbers take precedence
            over higher sequence numbers.
            </para>
            <example>
            If the model contains variables x0, x1 with domain { 0, 1, 2 } and the constraint x0 != x1, then specifying 0,1,2, 3,-1,-1 for complete 
            will result in x0 = 0 and x1 being unassigned since the only completable value specified is x1 = 0 with lower priority (rank 3 ) than x0 = 0 (rank 0).
            If we instead specify 0,1,2, 3,5,4 the the result will be x1 = 2 and x0 = 0.
            </example>
            <para>Set this property and <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionCosts"/> to null to reset completion priority to default model priority,
            in which all variables will be completed. This has the same effect
            as specifying the same positive priority for all values.</para>
            <remarks>Cannot be specified if <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionCosts"/> are specified.</remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionCosts">
            <summary>
            <para> 
            In global value ordering (see <see cref="M:Configit.Core.Model.VariableCollection.GetGlobalValueIndex(System.Int32,System.Int32)"/>) provides a cost for each value in the model
            (must be of length <see cref="P:Configit.Core.Model.VariableCollection.ValueCount"/>). Use <see cref="F:System.Double.NaN"/> to indicate that the value should
            not be targeted for completion. All such values will use the same fixed cost, and therefore it does not make sense to mark
            a subset of the values of a variable in this way, as it will skew the result.
            </para>
            <para>Set this property and <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/> to null to reset completion priority to default model priority,
            in which all variables will be completed. This has the same effect
            as specifying the same positive priority for all values.</para>
            <remarks>Cannot be specified if <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/> are specified.</remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ComputeSolutionCount">
            <summary>
            If true, the <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.SolutionCount"/> property
            will be updated.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.PublicVariables">
            <summary>
            Catalog of public variables
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions">
            <summary>
            Helpers extension methods for <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.HasAnyAssignments(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest)">
            <summary>
            Checks if any assignment has been made in the request
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.GetAssignedValues(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,System.Int32)">
            <summary>
            Returns all assigned values for a given variable
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.GetAssignedValues(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest)">
            <summary>
            Returns all assigned values in (public) global value index in ascending order.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.GetFlatAssignmentPriorities(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest)">
            <summary>
            Flattens the priority groups to a flat sequence of priorities for those
            valid domains solvers that cannot handle priority groups.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.SetFlatAssignmentPriorities(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Helper method for setting assignment priorities when there is only one variable in each priority group.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.HasAssignmentPriorities(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest)">
            <summary>
            Checks whether assignment priorities are required by the request.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.Prioritize(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,System.Int32)">
            <summary>
            <para>
            Put public <paramref name="publicVar"/> first in <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AssignmentSequence"/>, 
            ensuring that any assignments to <paramref name="publicVar"/> will be prioritized
            over assignments to any other variables.
            </para>
            <para>Note that <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AssignmentSequence"/> is not changed
            when calling <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ResetAllAssignments"/>, meaning the variable
            will remain prioritized, even though assignments are changed.</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.SetCompletionPriority(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the completion priority by public variable index and domain value.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.GetCompletionPriority(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,System.Int32,System.Int32)">
            <summary>
            Gets the completion priority by public variable index and domain value.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.SetCompletionPriorityToNone(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest)">
            <summary>
            Initializes <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/> such that no values are marked for completion.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequestExtensions.SetCompletionPriority(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{System.Int32}})">
            <summary>
            Sets completion priority from ranked global values.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse">
            <summary>
            <para>A valid domain response represents the result of applying a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>
            to a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>. It is intended that all implementations of <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>
            uses a dedicated valid domain request and response type to store the internal data used
            to represent the consequence of assigning
            value in a solve state. </para>
            <para>Creation of a response object can be expensive, so it should be cached
            and re-used whenever possible. </para>
            <para>All variable indices are public variable indices</para>
            <para>Operations on a solve response are not thread safe</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.ConflictingVariables">
            <summary>
            Indices of public variables with conflicting assignments that had to be removed to make 
            the configuration valid
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.GetUnconstrained(System.Int32,System.Int32)">
            <summary>
            <para>Returns true if value <paramref name="value"/> of <paramref name="publicVar"/>
            is valid according to the assignments in the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>.
            </para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.SolutionCount">
            <summary>
            Number of solutions satisfying <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>. This value 
            is only set if <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ComputeSolutionCount"/> is
            set to true. Otherwise, this value is 0.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.PublicVariables">
            <summary>
            Catalog of public variables
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.IsCompleteAssigned(System.Int32,System.Int32)">
            <summary>
            Indicates if <paramref name="value"/> is assigned as a completion during solve due to
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.Complete"/> being set to true.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.HasAcceptedAssignment(System.Int32,System.Int32)">
            <summary>
            Indicates if <paramref name="value"/> represents an accepted assignment to
            <paramref name="publicVariable"/>. Accepted assignments are those assignments
            from the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/> which have not been removed as a conflict.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.HasAcceptedAssignment(System.Int32)">
            <summary>
            Returns true if there are any accepted assignments to <paramref name="publicVariable"/>.
            Accepted assignments are those assignments
            from the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/> which have not been removed as a conflict.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.GetSpecificValue(System.Int32)">
            <summary>
            Get value which is either an accepted assigned value or an inferred value.
            </summary>
            <seealso cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.GetInferred(System.Int32)"/>
            <returns>Value which is either assigned or the inferred value. -1 if multiple
            values are accepted as assignments or if no specific value is inferred.</returns>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.GetSpecificAcceptedValue(System.Int32)">
            <summary>
            If a single value has been accepted for <paramref name="publicVar"/> its finite
            domain index is returned by this method, otherwise -1 is returned.
            <seealso cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.HasAcceptedAssignment(System.Int32,System.Int32)"/> for a definition of accepted.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse.GetInferred(System.Int32)">
            <summary>
            If only one value in the domain is unconstrained (meaning it's the only value
            that is valid), this returns the index of that value, otherwise it returns -1.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponseExtensions">
            <summary>
            Helpers extension methods for <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponseExtensions.GetCompletedValues(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <summary>
            Returns all values which are assigned due to completion in (public)
            global value index in ascending order.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponseExtensions.GetAcceptedAssignments(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse,System.Int32)">
            <summary>
            Get all assignment to <paramref name="publicVariable"/> which has been accepted
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponseExtensions.GetAcceptedAssignments(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <summary>
            Returns all accepted assigned values in (public) global value index in ascending order.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver">
            <summary>
            <para>
            Interface for valid domain solvers. A valid domain solver is a low-level solver
            that supplies functionality for determining the effect of applying assignments.
            Each call to <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)"/> is thread safe, given that each thread
            operates on its own <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/> and <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/>
            objects.
            </para>
            <para>All variable indices are on public variables</para>
            <para>
            A typical workflow for interactive solver would be to first create request / response
            objects by calling <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.CreateRequest"/> and <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.CreateResponse"/>.
            Then, for each user interaction, <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ResetAllAssignments"/> is called
            followed repeated calls to <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AddAssignment(System.Int32,System.Int32)"/> to build
            up the request. Then <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)"/> is called to populate the result into the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/>
            object.
            </para>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.SupportedFeatures">
            <summary>
            Defines which features are supported by each domain solver
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.PublicVariables">
            <summary>
            Variable index containing all public variables (that is, all variables except the private 
            ones)
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <summary>
            <para>Main solve method, which populates a <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/>
            object with the result of solving against the provided <paramref name="request"/>. </para>
            <para>If no <paramref name="response"/> object is provided, a new <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse"/>
            object is automatically created. However, for performance reasons, it is recommended to
            re-use any existing response objects, as these might be expensive to create.</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.CreateRequest">
            <summary>
            Creates a solve request objects used to hold all information used when solving. 
            A request object is designed to be re-used, as it might be expensive to create.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.CreateResponse">
            <summary>
            Creates a solve response objects used to hold the result of all information used when solving.
            A response object is designed to be re-used, as it might be expensive to create.
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest._completions">
            <summary>
            Intermediate data used by <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.SetupRanks(System.UInt32[])"/> but kept here to avoid reallocation
            on every call.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.RankByGlobalValue">
            <summary>
            Pre-allocated mapping of (public) global value -> rank.
            -1 indicates not ranked.
            <remarks>Cleared on every call.</remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.RankOffset">
            <summary>
            Indicates the lowest rank that is included in the current completion batch.
            <remarks>
            Used internally in conjunction with <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>
            Resets on every call to complete
            </remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.RanksInBatch">
            <summary>
            Indicates the number of priority ranks that are included in the current completion batch.
            <remarks>
            Used internally in conjunction with <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>
            Resets on every call to complete
            </remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.GetCompletionRank(Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32,System.Int32)">
            <summary>
            If the currently executing completion process does not
            target the given assignment this returns -1.
            Otherwise if using priorities this will return the index into the batch
            currently being processed corresponding to cost of the value.
            Otherwise if not using priorities it will return 0 indicating
            that the assignment is targeted for completion.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.GetPublicGlobalValuePriorityCompletionRank(System.Int32)">
            <summary>
            Returns the completion priority rank of a global value index.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.GetPublicUnassigned(Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)">
            <summary>
            Returns the public variable matching <paramref name="modelVar"/> if it is 
            unassigned, otherwise it returns -1.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.SetupRanks(System.UInt32[])">
            <summary>
            Responsible for setting up the data structures that concerns the ranking of the requested completions
            in <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>.
            This involves the following:
            <list type="bullet">
            <item>Normalizing sequence to rank (ie if sequence 10, 20 and 35 are used, then we have ranks 0,1,2)</item>
            <item>Populating <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.RankByGlobalValue"/></item>
            <item>Merging contigious ranks that refernce the same variable. <seealso cref="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.UpdateCostsOnMerge(System.UInt32[],Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry[],System.Int32,System.Int32)"/></item>
            </list>
            <returns>
            An array that for each rank holds an array of public global values belonging to that rank.
            </returns>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.SetRanksFromCompletions(Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry[],System.Int32,System.UInt32[])">
            <param name="completions">Array of <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry"></see> sorted by sequence.</param>
            <param name="completionsSize">The part of <paramref name="completions"/> that is populated.</param>
            <param name="longestPathCostByPublicValues"><see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest.CompletionCosts"/> 
            to be adjusted when sequences are merged.</param>
            <returns><see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.SetupRanks(System.UInt32[])"/></returns>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.GetRankValues(Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry[],System.Int32,System.Int32)">
            <summary>
            Selects the values from <paramref name="completions"/> from <paramref name="mergeStart"/> to <paramref name="mergeEnd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.UpdateCostsOnMerge(System.UInt32[],Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry[],System.Int32,System.Int32)">
            <summary>
            Updates <paramref name="longestPathCostByPublicValues"/> to reflect completions for the same variable 
            being combined into the same rank. Such a a merge is safe because a variable can only take one value,
            and is achieved by increasing the cost of the more important values to ensure their are prioritized
            correctly.
            <param name="mergeStart">Index into <paramref name="completions"/> for the first entry in the merge</param>
            <param name="mergeEnd">Index into <paramref name="completions"/>for the last entry in the merge</param>
            <param name="longestPathCostByPublicValues">The costs to update</param>
            <param name="completions">The completion entries sorted by sequence</param>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry">
            <summary>
            Represents an entry in <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>.
            <seealso cref="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.SetupRanks(System.UInt32[])"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry.Value">
            <summary>
            The global value index (as used to index <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>)
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry.Sequence">
            <summary>
            The sequence recorded at <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>[Value]
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry.CompareTo(Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest.CompletionEntry)">
            <summary>
            Sorts based on sequence
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.NamespaceDoc">
            <summary>
            Configuration capability representing all operations that can be performed during
            configuration.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NamespaceDoc">
            <summary>
            Configuration capability that a set of <see cref="T:Configit.Core.Noddy.Bdd"/>s, and is capable of configuring
            using a Just-In-Time compilation of the <see cref="T:Configit.Core.Noddy.Bdd"/>s into a static <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Ndd"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitCache">
            <summary>
            A simple cache that is able to JIT compile NDD's as required.
            It uses an LRU cache internally to limit the number of cached NDDs.
            <remarks>The cache is thread safe</remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitCache.GetScopeAssignmentKey(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <summary>
            Determines the scope assignment key (being a list of  value indices, matching the order
            in <see cref="F:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitCache._scopeVariablesByCacheKeyOrder"/>) based on a response. The scope key includes assignments
            inferred based on the assignments in the request.
            </summary>
            <returns>null if any scope variable does not have a single value assigned, and a list of 
            assigned value indices otherwise</returns>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainRequest">
            <summary>
            Request used for JIT operations, used to keep track of difference between scope and non-scope
            assignments.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainRequest.ScopeRequest">
            <summary>
            Request for NDD based scope solver
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainRequest.NonScopeQuery">
            <summary>
            Query object used to hold assignments for non scope
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainRequest.GetQuery(System.Int32)">
            <summary>
            Get query that holds assignments for <paramref name="publicVariable"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver">
            <summary>
            JIT based valid domain solver. Given an <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Ndd"/> describing the solution space for the scope variables, 
            it generates NDDs representing the solution space to the rest of the variables only when the scope variables have 
            been completed, either by being inferred or user assigned.
            This approach has some limitations, primarily that no information is available about the non-scope variables 
            before the scope has been completed. Until this point, the solver will report all non-scope variable values as 
            being unconstrained, resulting in a non-backtrack-free behavior. If blocked value information is included with
             the <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData"/> used to construct the solver, it will be able to provide blocked values 
            as being unavailable without the scope being defined.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddJitSolveData,Configit.Core.Model.VariableCatalog)">
            <summary>
            Create a domain solver that JIT compiles BDDs into an <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Ndd"/> as soon as the 
            scope variables have been set.
            </summary>
            <param name="data">Compiled scope NDD and BDDs used for JITting</param>
            <param name="variableCatalog">Variable index for public and model variables</param>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.SupportedFeatures">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.CreateRequest">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.CreateResponse">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.IsScope(System.Int32)">
            <summary>
            Returns true if variable is considered a scope variable
            </summary>
            <param name="variable">Public variable index of variable</param>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.PublicVariables">
            <summary>
            Variable index containing all public variables (that is, all variables except the private 
            ones)
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.JitScopeVariables">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.NddJit.NddJitValidDomainSolver.DumpDebugState(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,System.String)">
            <summary>
            Dump debug information to the provided folder. Debug information should
            present the underlying data structure and the current assignments.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NamespaceDoc">
            <summary>
            Configuration capability that reads a static <see cref="N:Configit.Core.Capabilities.ValidDomainSolvers.Ndd"/> and is capable of configuration
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.Ndd">
            <summary>
            Returns the underlying NDD.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.ValueCost">
            <summary>
            By variable/value, the cost associated with the assignment.
            At most one group will be non-zero and the value will always be 1.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.BestCostPerVar">
            <summary>
            Used to find the cost for complete edges in completion.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.NodeCostOdd">
            <summary>
            Stores the cost of nodes in an odd layer.
            Indexed by offset into layer
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.NodeCostEven">
            <summary>
            Stores the cost of nodes in an even layer.
            Indexed by offset into layer
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.EdgeMarks">
            <summary>
            Used to mark the optimal path in <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.ValidateAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)"/>
            and <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Complete(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.EdgePathMarks">
            <summary>
            Used to mark whether a path exist to the terminal
            through the edge. Used in solution counting and enumeration.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.NodePathMarks">
            <summary>
            The path mark indicates if there is a valid path from node
            to terminal TRUE
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.NodeTempMarks">
            <summary>
            Marker used for temporary marking a node
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.SolCountsOdd">
            <summary>
            Place holder for caching solution count for odd variable indices
            TODO: This is also convenient for cost opt.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.SolCountsEven">
            <summary>
            Place holder for caching solution count for even variable indices
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.GetBestCompletionValue(Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32)">
            <summary>
            Returns the domain value index of the optimal value for 
            the given model variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.ToString">
            <summary>
            Stringifier purely for debugging purposes
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver">
            <summary>
            Valid domain solver for <see cref="N:Configit.Core.Structure.Ndd"/> using 
            a shortest path algorithm for conflict resolution and completion.
            </summary>
            <summary>
            Valid domain solver for <see cref="N:Configit.Core.Structure.Ndd"/> using 
            a shortest path algorithm for conflict resolution and completion.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MaxGroupsPerBatch">
            <summary>
            For testing purposes only (set via reflection). Used to
            force multiple phases in small test cases for conflict resolution
            and completion.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.#ctor(Configit.Core.Structure.Ndd.Ndd,Configit.Core.Model.VariableCatalog)">
            <summary>
            Create a new <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/> working on the specified
            <paramref name="ndd"/> and <paramref name="variableCatalog"/>. This constructor
            is provided to make it easy to solve directly against an <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Ndd"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.#ctor(Configit.Core.Capabilities.ValidDomainSolvers.CompiledData.NddSolveData,Configit.Core.Model.VariableCatalog)">
            <summary>
            Creates a valid domain solver for the provided NDD solve data.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Ndd">
            <summary>
            Returns the <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Ndd"/> associated
            with the solver.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.SupportedFeatures">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.CreateRequest">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.CreateResponse">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)">
            <inheritdoc />
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.PublicVariables">
            <summary>
            Variable index containing all public variables (that is, all variables except the private 
            ones)
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MostImportantBit">
            <summary>
            The most important bit in the node penalties is used
            to as penalty for variables that have been verified 
            in previous batches.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MarkOptimalAssignPath(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest)">
            <summary>
            Marks the optimal path through the <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Ndd"/> in terms of minimizing
            the conflict as well updating <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.NodePathMarks"/> and
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.EdgePathMarks"/>, so that those marks are valid
            if there is no conflict, corresponding to the root cost being 0. If root cost
            is non-zero, then the <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.EdgeMarks"/> marks the optimal
            path from the root.
            <remarks>
            Very similar to <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MarkOptimalCompletePath(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest)"/>, but differs in that
            it writes the path marks instead of reading them and assumes minimization.</remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.ProcessCompletionPriorities(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)">
            <summary>
            When calling this method we know that the <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.NodePathMarks"/> and
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.EdgePathMarks"/> are up to date.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.CompleteUnusedVariables(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)">
            <summary>
            Adds an assignment to any prioritized (non-private) variables
            that are not represented as a layer in the <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Ndd"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.HasCompletionPriority(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,System.Int32)">
            <summary>
            Returns true if completion priority is set to a positive value,
            or request.CompletionSequence is null.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.GetMostImportantCompletionValue(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,System.Int32)">
            <summary>
            Returns the highest priority domain value for the given public variable
            (according to request.CompletionSequence)
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.SetCompletionValueCosts(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder,System.UInt32[])">
            <summary>
            Updates <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest.ValueCost"/> 
            for the current batch based on the provided costs.
            </summary>
            <param name="request">The request to be updated</param>
            <param name="response">Response containing information about valid assignments and their consequences</param>
            <param name="batchCostEncoding">The current batch cost encoding.</param>
            <param name="lpCosts">The costs to use by global value index.</param>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.AddCompletedAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32,Configit.Core.Structure.Ndd.NddTable.NddEdge)">
            <summary>
            Completes a variable based on an <see cref="T:Configit.Core.Structure.Ndd.NddTable.NddEdge"/> if value is prioritized
            in the current batch.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MarkOptimalCompletePath(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest)">
            <summary>
            Marks the optimal path through the <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.Ndd"/> in terms of maximizing
            the completion achieved.
            <seealso cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MarkOptimalAssignPath(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.InitForOptimalPath(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Structure.Ndd.Ndd)">
            <summary>
            Setup before running <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MarkOptimalAssignPath(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest)"/>
            and <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.MarkOptimalCompletePath(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.SetPathMarksFromAssignments(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Boolean)">
            <summary>
            Updates the node path marks and edge path marks based on the current assignments. It is
            intended to be called only after any conflict has been resolved. If <paramref name="trustPathMarks"/>
            is set then edge marks below false marked nodes will *not* be updated.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.GetSolutionCount(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)">
            <summary>
            Get number of solutions satisfying last applied assignments
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainSolver.UpdateUnconstrained(Configit.Core.Capabilities.ValidDomainSolvers.Ndd.NddValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse)">
            <summary>
            For each variable identify values that can be assigned wo. conflicting 
            with values to other variables.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.OptimalPathBatchEncoder">
             <summary>
             Generates <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder"/>'s for representing shortest/longest path costs
             in the graph algorithms for <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)"/>. It is responsible for splitting
             up the assignments/completions into batches so that the cost can be encoded in
             a 64-bit unsigned integer.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.OptimalPathBatchEncoder.MaxGroupsPerBatch">
            <summary>
            Can be used during debugging/testing to limit
            the number of groups encoded in a single
            batch
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.OptimalPathBatchEncoder.CreateAssignmentEncoders(System.Collections.Generic.IEnumerable{System.Collections.Generic.IReadOnlyList{System.Int32}})">
            <summary>
            Creates a set of <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder"/> that encodes the 64-bit unsigned integer cost
            such that it will never overflow between priority groups when costs are summed during
            the assignment algorithm.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.OptimalPathBatchEncoder.CreateNextCompletionEncoder(Configit.Core.Capabilities.ValidDomainSolvers.LongestPathCompletionBaseRequest,Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse,System.Int32[][],System.UInt32[])">
            <summary>
            Creates an <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IntArrayEncoder"/> for the next batch used during complete.
            <remarks>
            Unlike for standard solve we dont want to allocate all the
            encodings up front, as the priority group size can change after a batch is applied because completion
            can include multiple values per variable.</remarks>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.SupportedDomainSolverFeatures">
            <summary>
            Flags identifying which features are supported by a specific <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver"/>.
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.SupportedDomainSolverFeatures.BasicSolve">
            <summary>
            Provided as value to be returned if no other features are supported
            indicating that <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)"/> will
            check assignments and find conflicts, and that the response will
            be populated with un-constrained values
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.SupportedDomainSolverFeatures.SequencedCompletion">
            <summary>
            Support for <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.SupportedDomainSolverFeatures.CostBasedCompletion">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionCosts"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Capabilities.ValidDomainSolvers.SupportedDomainSolverFeatures.SolutionCount">
            <summary>
            Support for <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ComputeSolutionCount"/>.
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery">
            <summary>
            Data that holds the actual query of an <see cref="T:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest"/>
            The query part includes the assignments, settings for completion, 
            priorities etc.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.ModelVarAssignments">
            <summary>
            Value assignments made to model variables. Represents assignments made by the user.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.Complete">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.Complete"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.CompletionSequence">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionSequence"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.CompletionCosts">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.CompletionCosts"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.ComputeSolutionCount">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ComputeSolutionCount"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.AssignmentSequence">
            <summary>
            <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AssignmentSequence"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.VariableCatalog">
            <summary>
            Variable catalog defining both model and public variables, and the mapping
            between them
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.AddAssignment(System.Int32,System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.AddAssignment(System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.RemoveAssignments(System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.RemoveAssignments(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.HasAssignment(System.Int32,System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.HasAssignment(System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.HasAssignment(System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.HasAssignment(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.ResetAllAssignments">
            <summary>
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.ResetAllAssignments"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.Reset">
            <summary>
            <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest.Reset"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse">
            <summary>
            Response object that comes from a <see cref="M:Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainSolver.Solve(Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainRequest,Configit.Core.Capabilities.ValidDomainSolvers.IValidDomainResponse)"/>
            operation
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.PrepareForSolve(Configit.Core.Capabilities.ValidDomainSolvers.BaseValidDomainRequest)">
            <summary>
            Copy assignments from request to response. Assignments in request are not changed
            during solve - but the assignments in the repose will be.
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.ConflictingVariables">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.GetUnconstrained(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.SolutionCount">
            <inheritdoc />
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.PublicVariables">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.IsCompleteAssigned(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.GetSpecificAcceptedValue(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.HasAcceptedAssignment(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.HasAcceptedAssignment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.GetSpecificValue(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.GetInferred(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.RemoveAcceptedModelAssignments(System.Int32)">
            <summary>
            Removes assignments to a variable specified in model variable index.
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.AddAcceptedModelAssignment(System.Int32,System.Int32)">
            <summary>
            Add value as assignment. This is used during complete
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.ModelVarUnconstrained">
            <summary>
            Indication of which of the model values are unconstrained
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.AcceptedModelVarAssignments">
            <summary>
            The pruned <see cref="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainRequestQuery.ModelVarAssignments"/>, 
            representing all assignments which are valid. Contains both user and completed assignments
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.CompletedModelVarAssignments">
            <summary>
            Assignments added by a completion during solve
            </summary>
        </member>
        <member name="P:Configit.Core.Capabilities.ValidDomainSolvers.ValidDomainResponse.AcceptedModelVarAssigned">
            <summary>
            Variables for which at least one assignment has been accepted
            </summary>
        </member>
        <member name="T:Configit.Core.Capabilities.VariableDefinitionExtensions">
            <summary>
            Extension methods for <see cref="T:Configit.Core.Model.VariableDefinitions.VariableDefinition`1"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Capabilities.VariableDefinitionExtensions.TryGetGlobalValueIndex(Configit.Core.Model.VariableCollection,Configit.Core.Model.VariableDefinitions.Assignment)">
            <summary>
            Gets the global value index corresponding to the assignments.
            </summary>
            <param name="variables"></param>
            <param name="assignment"></param>
            <returns>Global value index or -1 if value does not exist in the domain</returns>
        </member>
    </members>
</doc>
