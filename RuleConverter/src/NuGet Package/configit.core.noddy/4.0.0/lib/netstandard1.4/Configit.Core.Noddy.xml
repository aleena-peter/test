<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Configit.Core.Noddy</name>
    </assembly>
    <members>
        <member name="T:Configit.Core.Noddy.Algorithms.Algorithms">
            <summary>
            Collection of algorithms used manipulate sets of BDDs for example during compilation of product models.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.#ctor(Configit.Core.Noddy.Noddy)">
            <summary>
            Constructs instance specific to a given Noddy instance.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.Algorithms.Splitter">
            <summary>
            Made as property to support <see cref="M:Configit.Core.Noddy.Bdd.Split"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.ProcessBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Algorithms.ProcessingStep},System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>
            Process input BDDs using specified <paramref name="processingSteps"/>. The processing
            steps will be performed in the specified sequence.
            </summary>
            <remarks>Domain constraints are not applied.</remarks>
            <param name="bdds">The BDDs to process</param>
            <param name="conjoinLimit">Used with <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.ConjoinWithLimit"/> to control when to terminate
            conjunction. Default is <see cref="F:System.Int32.MaxValue"/> which means all values will be conjoined</param>
            <param name="privateVars">Used with <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.ConjoinWithLimit"/> to remove private variable. Default
            is null meaning no private variables are to be used.</param>
            <param name="skipSplitIfSupersetDoesNotSplit">Used for <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.Split"/> to control
            if certain BDDs should not be skipped. See <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Split(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean)"/> for further details. Default is false.</param>
            <param name="processingSteps">The processing step that the input BDDs should go through</param>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.Conjoin(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Attempts to conjoin the input BDDs in an intelligent order.
            </summary>
            <param name="bdds">BDDs to conjoin</param>
            <param name="propagateConstants">If true, all single path BDDs are propagated before conjunction starts</param>
            <param name="privateVars">Private BDD variables that are to be existentially quantified from result</param>
            <returns>The conjunction of the input BDDs.
            Returns the singleton <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> in case the empty set is given as input
            </returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinWithLimit(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Same as <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Conjoin(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})"/> except that any intermediate result with node count above <paramref name="nodeLimit"/> will not be
            processed further. As the processing might be stopped when the intermediate results reaches the
            <paramref name="nodeLimit"/>, the result might contain multiple BDDs.
            </summary>
            <remarks>Will not apply domain constraints as conjunction keeps domain constraints. If input has
            domain constraints applied, so will the output.</remarks>
            <returns>A set of BDDs that can be conjoined to the same result as the input BDDs.
            Returns the singleton <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> in case the empty set is given as input
            </returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.Disjoin(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Fast disjunction of multiple <see cref="T:Configit.Core.Noddy.Bdd"/>s. Organizes BDDs
            in a balanced binary tree, and builds bottom up.
            </summary>
            <returns>The disjunction of the input BDDs.
            Returns the singleton <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/> in case the empty set is given as input
            </returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.BuildTable(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Int32}})">
            <summary>
            <para>
            Create a <see cref="T:Configit.Core.Noddy.Bdd"/> representing tabular data. The tabular data is represented
            as an enumeration of rows, each row being an element in <paramref name="table"/>.
            </para>
            <para>Each row in <paramref name="table"/> must have as many columns are represented by
            <paramref name="fdVariables"/>, so cell with index i in a row
            represents the value for the finite domain values <paramref name="fdVariables"/>[i]</para>
            </summary>
            <remarks>Using this method for building large disjunctions is provided as a faster
            alternative to calling <see cref="M:Configit.Core.Noddy.Noddy.FdConstAssignments(System.Collections.Generic.IEnumerable{System.Int32})"/>
            on each row, followed by a call to <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Disjoin(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/> for the resulting <see cref="T:Configit.Core.Noddy.Bdd"/>s
            representing the rows. Also, using this method should consume less memory, as all
            intermediate <see cref="T:Configit.Core.Noddy.Bdd"/> for the resulting rows need not be created.</remarks>
            <exception cref="T:System.ArgumentException">If some of the row in the table does not contain the same
            number of cells as specified by the <paramref name="fdVariables"/>, or if the same variable
            is mentioned more than once in <paramref name="fdVariables"/>.</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.BuildTable(System.Collections.Generic.IEnumerable{System.Int32},System.Int32[][])">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.BuildTable(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Int32}})"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinBalancedTree(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Fast conjunction of multiple <see cref="T:Configit.Core.Noddy.Bdd"/>s. Organizes BDDs
            in a balanced binary tree, and builds bottom up.
            </summary>
            <returns>The conjunction of the input BDDs.
            Returns the singleton <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> in case the empty set is given as input
            </returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.TrueCount(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Get count representing how many of the input BDDs evaluate to true.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.TrueCount(Configit.Core.Noddy.Bdd[])">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.TrueCount(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.PropagateAndRestrictConstants(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},Configit.Core.Noddy.Bdd@)">
            <summary>
            Extract any constant assignments to the BDD variables in the input BDDs, and propagate the constants
            to all BDDs which support set contains a BDD variable for which a constant assignment
            has been found. The propagation will <see cref="M:Configit.Core.Noddy.Bdd.Restrict(Configit.Core.Noddy.Bdd)"/> the constant BDDs from
            the input BDDs and collect all constant BDD variables into a single-path BDD returned in
            <paramref name="constants"/>.
            </summary>
            <remarks>Will not apply domain constraints as conjunction keeps domain constraints. If input has
            domain constraints applied, so will the output.</remarks>
            <returns>A set of BDDs where constants have been restricted, and a single path BDD representing
            all found constant BDD variables. The conjunction of the input will equal
            the conjunction of the output including the constants.
            Returns the empty set and <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> in <paramref name="constants"/>
            in case the empty list is given as input.
            </returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinSupportSubsetWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            <para>Attempts to conjoin similar <see cref="T:Configit.Core.Noddy.Bdd"/>s based on their support set. </para>
            <para>Given a set of <see cref="T:Configit.Core.Noddy.Bdd"/>s, if any pair exist such that
            the support of one is a subset of the other, then they are conjoined.</para>
            </summary>
            <remarks>Will not apply domain constraints as conjunction keeps domain constraints.
            If input has domain constraints applied, so will the output. </remarks>
            <returns>Mapping from conjoined <see cref="T:Configit.Core.Noddy.Bdd"/>s to their source
            <see cref="T:Configit.Core.Noddy.Bdd"/>s. If no <see cref="T:Configit.Core.Noddy.Bdd"/>s are merged it returns
            the identity mapping.</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinSupportSubset(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinSupportSubsetWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.UnaryConstraintPropagation(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Merges/Conjoins any constraint over only one variables into any
            other constraint having that variable.
            </summary>
            <param name="bdds"> The input list of BDDs for processing</param>
            <returns>The processed list of output BDDs.</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.UnaryConstraintPropagationWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Merges/Conjoins any constraint over only one variables into any
            other constraint having that variable.
            </summary>
            <param name="bdds"> The input list of BDDs for processing</param>
            <returns>Mapping from merged/conjoined BDDs to their source BDDs. If no BDDs are merged it is the identity mapping.</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.SplitWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean)">
            <summary>
            <para>Attempts to split each BDD B into a set of BDDs that when conjoined yields B. For each BDD in the split
            the input BDD has at least one finite domain variable in its support not present in the split BDD.</para>
            <para>Can be used to prepare a set of BDDs for dependency analysis.</para>
            <remarks>All input BDDs must be defined over finite domain variables</remarks>
            </summary>
            <remarks>Will not apply domain constraints to the result</remarks>
            <returns>A mapping from a split BDD to a set ( usually singleton ) of BDDs that was the source of the split </returns>
            <param name="bdds">Collection of <see cref="T:Configit.Core.Noddy.Bdd"/>s that should be split into a set of smaller BDDs</param>
            <param name="skipBddIfSupersetNotSplit">If this is true, then splitting will not be
            attempted on BDDs for which the <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/> is a true subset
            of another BDD which could not be split. Example: if BDD with finite domain variable support [b,c,d,e,f]
            could not be split, then the algorithm will not try to split a BDD with finite domain variable support
            [c,e,f]. This option is useful if the results of split is later merged using
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinSupportSubsetWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>.</param>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.Split(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean)">
            <summary>
            <para>Attempts to split each BDD B into a set of BDDs that when conjoined yields B. For each BDD in the split
            the input BDD has at least one finite domain variable in its support not present in the split BDD.</para>
            <para>Can be used to prepare a set of BDDs for dependency analysis.</para>
            <remarks>All input BDDs must be defined over finite domain variables</remarks>
            </summary>
            <remarks>Will not apply domain constraints to result</remarks>
            <returns>List of distinct BDDs that when conjoined yields the same result as the input <paramref name="bdds"/></returns>
            <param name="bdds">Collection of <see cref="T:Configit.Core.Noddy.Bdd"/>s that should be split into a set of smaller BDDs</param>
            <param name="skipBddIfSupersetNotSplit">If this is true, then splitting will not be
            attempted on BDDs for which the <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/> is a true subset
            of another BDD which could not be split. Example: if BDD with finite domain variable support [b,c,d,e,f]
            could not be split, then the algorithm will not try to split a BDD with finite domain variable support
            [c,e,f]. This option is useful if the results of split is later merged using
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinSupportSubsetWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>.</param>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.RelaxWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Same as <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Relax(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/> but where result keeps track of which input BDDs
            where used to yield each resulting BDD
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.Relax(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            <para> Create list of simplified BDDs that when conjoined yields the same result as when the set of input
            BDDs are conjoined. Each simplification is identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Relax(Configit.Core.Noddy.Bdd)"/></para>
            <para>The output contains the same or smaller number of BDDs than the input. The sum of the node counts for the
            output BDDs will be equal or less than the sum of the node counts for the input BDDs</para>
            </summary>
            <remarks>Will not apply domain constraints to result</remarks>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.SimplifyWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Same as <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Simplify(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/> but where result keeps track of which input BDDs
            where used to yield each resulting BDD
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.Simplify(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            <para> Create list of simplified BDDs that when conjoined yields the same result as when the set of input
            BDDs are conjoined. Each simplification is identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Simplify(Configit.Core.Noddy.Bdd)"/></para>
            <para>The output contains the same or smaller number of BDDs than the input. The sum of the node counts for the
            output BDDs will be equal or less than the sum of the node counts for the input BDDs</para>
            </summary>
            <remarks>Will not apply domain constraints to result</remarks>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.NeighborSync(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            <para> Synchronizes solutions in each pair of input BDDs having at least one common variable, such that
            any solution for one BDD can be extended to a solution for the other BDD having a common variable.</para>
            <para>  The output will be such that there will be a one-to-one mapping between the input BDDs and output BDDs,
            where an output BDD will contain a subset of solutions in the corresponding input BDD.
            Also, the property that the conjunction of input BDDs will be the same as the conjunction
            of the output BDDs will hold.</para>
            </summary>
            <param name="bdds"> Input BDDs to be neighbor synchronized </param>
            <returns> The set of neighbor synchronized BDDs </returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.FindUnsatCore(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},Configit.Core.Noddy.Bdd,System.Int32)">
            <summary>
            Finds the subset of <paramref name="bdds"/> that when conjoined with <paramref name="target"/>
            yields <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>.
            If <paramref name="preProcessConjoinLimit"/> is set,
            the algorithm will try to pre-conjoin roots when checking for satisfiability. See <see cref="M:Configit.Core.Noddy.Algorithms.Conjoiner.ConjoinWithLimit(System.Collections.Generic.IEnumerable{System.Int32},System.Boolean,System.Collections.Generic.IEnumerable{System.Int32},System.Int32)"/>
            </summary>
            <returns>The subset of the <paramref name="bdds"/> that when conjoined with <paramref name="target"/>
            yields false. If <paramref name="target"/> can be conjoined with all <paramref name="bdds"/>
            without resulting in false, null is returned.</returns>
            <exception cref="T:System.ArgumentException">If target itself is false</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.IntMappingToBddMapping(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Int32,System.Collections.Generic.HashSet{System.Int32}}},System.Boolean)">
            <summary>
            Turn mapping from int->int* into BDD->BDD*. Will apply domain constraints if required.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.UniquelyDefinesCounterExample(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},Configit.Core.Noddy.Algorithms.UniquelyDefinesCounterExampleMode)">
            <summary>
            Returns a BDD representing the part of the solution space (projected onto master and slave variables)
            for which the master variables do not infer a single value for each for the slave variables.
            <example>
            <para>
            Assume the solution space over variables x, y is:
            x y
            0 1
            1 1
            1 0
            </para>
            <para>
            If master variable is x and slave variable is y then the resulting solution space is:
            x y
            1 1
            1 0
            </para>
            (0,1) is not included as it belongs to the part of the solution space for which
            x does define y completely.
            </example>
            </summary>
            <param name="bdds">A set of bdds to test the conjunction of</param>
            <param name="masterFd">The master finite domain variables</param>
            <param name="slaveFd">The slave finite domain variables</param>
            <param name="mode">The counter example mode to use, <see cref="T:Configit.Core.Noddy.Algorithms.UniquelyDefinesCounterExampleMode"/> for more detail.</param>
            <exception cref="T:System.ArgumentException">If the slave and master variables overlap</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.UniquelyDefines(Configit.Core.Noddy.Bdd,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Returns true if any valid assignment of master finite domain variables will allow exactly one value for each slave variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Algorithms.UniquelyDefines(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Returns true if any valid assignment of master finite domain variables will allow exactly one value for each slave variable.
            </summary>
            <param name="bdds">A set of BDDs, the conjunction of which will be tested.</param>
            <param name="masterFd">Master finite domain variable indices</param>
            <param name="slaveFd">Slave finite domain variable indices</param>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.Conjoiner">
            <summary>
            Conjoins bdds in intelligent order.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Conjoiner.ConjoinSupportSubset(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Equivalent to <see cref="M:Configit.Core.Noddy.Algorithms.Conjoiner.ConjoinSupportSubsetWithTracking(System.Collections.Generic.IEnumerable{System.Int32})"/> without merge tracking.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Conjoiner.ConjoinSupportSubsetWithTracking(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinSupportSubsetWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>.
            Note: input roots must be reference counted. Output is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Conjoiner.UnaryConstraintPropagation(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.UnaryConstraintPropagation(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>.
            Note: input roots must be reference counted. Output is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Conjoiner.UnaryConstraintPropagationWithTracking(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.UnaryConstraintPropagationWithTracking(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>.
            Note: input roots must be reference counted. Output is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Conjoiner.ConjoinWithLimit(System.Collections.Generic.IEnumerable{System.Int32},System.Boolean,System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Conjoin multiple BDDs in an intelligent sequence. If <paramref name="conjoinLimit"/> is used, the
            result might be multiple BDDs. If no limit is set, the result will be a single BDD.
            Input should not contain duplicates.
            Note: It is assumed the inputs BDDs are reference counted. The results are not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Conjoiner.ConjoinWithPriorityQueue(System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Create conjunction using a priority queue for handling private variables. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Conjoiner.PropagateAndRestrictConstants(System.Collections.Generic.List{System.Int32},System.Int32@)">
            <summary>
            Extract any constant assignments to the BDD variables in the input BDDs, and propagate the constants
            to all BDDs which support set contains a BDD variable for which a constant assignment
            has been found. The propagation will <see cref="M:Configit.Core.Noddy.Bdd.Restrict(Configit.Core.Noddy.Bdd)"/> the constant BDDs from 
            the input BDDs and collect all constant BDD variables into a single-path BDD returned in.
            Returns distinct list of roots;
            <paramref name="constants"/>.
            Note: It is assumed that the inputs are reference counted. 
            The results are not reference counted.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue">
            <summary>
            Keep track of BDDs to be conjoined. Keep track of which entries in queue uses which
            private variables.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue.Push(Configit.Core.Noddy.Kernel.BddPriorityKey)">
            <summary>
            Insert BDD into queue and keep track of private variables. Return true if 
            key is inserted, false if it is already in queue
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue.Remove(Configit.Core.Noddy.Kernel.BddPriorityKey)">
            <summary>
            Remove entry from queue and keep track of private variables
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue.Get(System.Int32)">
            <summary>
            Get Bdd key that represents the specified root
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue.BddCount">
            <summary>
            Number of BDDs in queue
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue.PrivateVarCount">
            <summary>
            Number of private variables that have not been quantified out
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue.QuantifyPrivateReferences">
            <summary>
            Run through all BDDs in queue and quantify out all private variables that are 
            only mentioned in a single BDD
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.ConjoinPriorityQueue.PopArguments(Configit.Core.Noddy.Kernel.BddPriorityKey@,Configit.Core.Noddy.Kernel.BddPriorityKey@)">
            <summary>
            Get next two BDDs to be conjoined. Will priorities BDDs that can help 
            eliminate private variables.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.DisjointSet`1">
            <summary>
            Implementation of http://en.wikipedia.org/wiki/Disjoint-set_data_structure 
            </summary>
            <typeparam name="T">Item data type</typeparam>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.InternalAlgorithm">
            <summary>
            Base class used to provide helper methods for operating on
            BDD roots, and doing basic reference counting. All methods returns
            reference counted roots, which should be freed by calling 
            <see cref="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.DecRefAll"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Noddy">
            <summary>
            Current <see cref="T:Configit.Core.Noddy.Noddy"/> instance
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.InternalAlgorithm.BinOperations">
            <summary>
            Get <see cref="P:Configit.Core.Noddy.Algorithms.InternalAlgorithm.BinOperations"/> associated with current
            <see cref="P:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Noddy"/> instance
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.InternalAlgorithm.FdOperations">
            <summary>
            Get <see cref="P:Configit.Core.Noddy.Algorithms.InternalAlgorithm.FdOperations"/> associated with current
            <see cref="P:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Noddy"/> instance
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.#ctor(Configit.Core.Noddy.Noddy)">
            <summary>
            Create sets for helping with internal reference counting
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.And(System.Int32,System.Int32)">
            <summary>
            Conjoint roots, and increment ref count on result
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Or(System.Int32,System.Int32)">
            <summary>
            Disjoin roots, and increment ref count on result
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Not(System.Int32)">
            <summary>
            Negate root, and increment ref count on result
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Restrict(System.Int32,System.Int32)">
            <summary>
            Restrict <paramref name="root"/> with <paramref name="constants"/>,
            and increment ref count on result
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Exist(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Existential quantify out <paramref name="quantBddVars"/> from
            <paramref name="root"/> and increment ref count on result
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.ExistFd(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Existential quantify out all BDD variables representing
            <paramref name="quantFdVars"/> and increment ref count on result
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.Satisfy(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Find some solution that satisfies roots, and increment result
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.FdVarsExcept(System.Int32,System.Int32)">
            <summary>
            All FD variables in <paramref name="root"/> that are not in <paramref name="subtract"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.IncRef(System.Int32)">
            <summary>
            Helper for reference counting. Can be called numerous time with same root.
            Remember to call <see cref="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.DecRefAll"/> before terminating
            the algorithm.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.InitializeRefCount">
            <summary>
            Call this method before starting the algorithm, to handle reference counting
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.DecRefAll">
            <summary>
            Must be called before returning from the algorithm in case 
            <see cref="M:Configit.Core.Noddy.Algorithms.InternalAlgorithm.IncRef(System.Int32)"/> has been called at all
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.NamespaceDoc">
            <summary>
            Advanced algorithms for working on <see cref="T:Configit.Core.Noddy.Bdd"/>s
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.NeighborSynchronizer">
            <summary>
            Synchronizes solutions in each pair of BDD having at least one common variable, such that
            any solution for one BDD can be extended to a solution for the other BDD having a common variable. 
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.ProcessingStep">
            <summary>
            Definitions of processing steps that can be performed using 
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.ProcessBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Algorithms.ProcessingStep},System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.ConjoinWithLimit">
            <summary>
            Conjoin BDDs until one of the BDDs reaches a certain limit. Constants are not propagated first, 
            use step <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.PropagateAndRestrictConstants"/> to do this. This processing step 
            is identical to <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinWithLimit(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{System.Int32})"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.ConjoinSupportSubset">
            <summary>
            Conjoin pairs of BDDs where one of the bdds support is a subset of the other bdds support. 
            Identical to <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.ConjoinSupportSubset(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.PropagateAndRestrictConstants">
            <summary>
            Propagate and restrict constant BDD variable assignments across all BDDs. Identical
            to <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.PropagateAndRestrictConstants(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},Configit.Core.Noddy.Bdd@)"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.UnaryConstraintPropagation">
            <summary>
            Merges any constraint over only one variables into any 
            other constraint having that variable. Identical
            to <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.UnaryConstraintPropagation(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.Relax">
            <summary>
            Relax all BDDs against each other. Identical to <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Relax(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.Simplify">
            <summary>
            Simplify all BDDs against each other. Identical to <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.Simplify"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.Split">
            <summary>
            Split all BDDs into smaller BDDs. Identical to <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Split(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean)"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.ProcessingStep.NeighborSync">
            <summary>
            Synchronizes solutions in each pair of BDD having at least one common variable, such that
            any solution for one BDD can be extended to a solution for the other BDD having a common variable. 
            Identical to <see cref="T:Configit.Core.Noddy.Algorithms.NeighborSynchronizer"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.Simplifier">
            <summary>
            Implements algorithms useful for simplifying/relaxing collections of BDDs before compilation or dependency analysis
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Simplifier.SimplifyOrRelax(System.Collections.Generic.IEnumerable{System.Int32},Configit.Core.Noddy.Operators.OtherBddOpr)">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Simplify(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>, <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Relax(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>
            Returns distinct list of roots; 
            Note: input BDDs must be reference counted, output roots are not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Simplifier.SimplifyOrRelaxWithTracking(System.Collections.Generic.IEnumerable{System.Int32},Configit.Core.Noddy.Operators.OtherBddOpr,System.Boolean)">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Simplify(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>, <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Relax(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>
            Returns distinct list of roots, including tracking. 
            Note: input BDDs must be reference counted, output roots are not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Simplifier.TrackChanges(Configit.Core.Noddy.Algorithms.Simplifier.Tracking[],System.Int32,System.Int32)">
            <summary>
            Track that <paramref name="simplifier"/> has been used to simply
            <paramref name="simplified"/>. 
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.SortedEnumerableInt">
            <summary>
            Helper class for working on sorted Enumerables of int
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.SortedEnumerableInt.Overlaps(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Check if there is an overlap between two sets. 
            The sets must be sorted in ascending order.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.SortedEnumerableInt.IsSuperSetOf(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Check if all values in <paramref name="subset"/> also belongs to <paramref name="superSet"/>. 
            If <paramref name="subset"/> is empty and <paramref name="superSet"/> is not, 
            then true is returned.
            </summary>
            <remarks>For this operation to work, the input sets must be sorted.</remarks>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.SplittableKey">
            <summary>
            Key used for caching in <see cref="M:Configit.Core.Noddy.Algorithms.Splitter.IsSplittable(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.Splitter">
            <summary>
            Method for splitting a BDDs into multiple BDDs, ensuring the conjunction
            of the result is the same as the input
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.#ctor(Configit.Core.Noddy.Noddy)">
            <summary>
            Creates a splitter for splitting BDDs belonging to the provided <see cref="T:Configit.Core.Noddy.Noddy"/> instance
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.Split(System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Split(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.SplitWithTracking(System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>
            <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.Split(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.Split(System.Int32)">
            <summary>
            Attempt to split input BDD into multiple BDDs, where the conjunction
            is the same as the input. 
            Note: It is assumed the input is reference counted. Output is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.SplitRec(System.Int32)">
            <summary>
            Recursive call on split. Will populate _splitResult with resulting splits. Roots 
            in _splitResult are reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.SplitSinglePath(System.Int32,System.Int32)">
            <summary>
            Split single path BDD into multiple BDDs
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.IsSplittable(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Determines whether a split is valid. This is generally significantly faster than performing
            the two exist. quant. and then applying the result to check.
            </summary>
            <param name="root">The original BDD root.</param>
            <param name="fdLeft">The finite domain variables to exclude from left split</param>
            <param name="fdRight">The finite domain variables to exclude from right split</param>
            <returns>True if the split is valid, false otherwise.</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.IsSplittable(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Same as <see cref="M:Configit.Core.Noddy.Algorithms.Splitter.IsSplittable(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})"/> except that left and right starting roots
            can be specified. This is relevant when the split has already been generated and is in the process of being extended.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.Splitter.SplitContext">
            <summary>
            Helper class to avoid cluttering the <see cref="M:Configit.Core.Noddy.Algorithms.Splitter.IsSplittableRec(System.Int32,System.Int32,System.Int32,Configit.Core.Noddy.Algorithms.Splitter.SplitContext)"/> call with 
            a lot of information that remains the same from call to call.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.IsSplittableRec(System.Int32,System.Int32,System.Int32,Configit.Core.Noddy.Algorithms.Splitter.SplitContext)">
            <summary>
            Searches for a path to <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddFalse"/> in the original BDD for which
            it is possible to find a path to <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddTrue"/> in both the generated splits.
            In this case we know that the split is not valid, as that particular path would be a solution
            in the conjunction of the two splits. If we cannot find such a path, the split is valid.
            <remarks>The two splits are not generated, the original BDD is simply traversed by visiting both low and
            high for any split variable.</remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.FindFirstSplit(System.Int32,System.Int32[],System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32@,System.Int32@)">
            <summary>
            Return true if input root can be split into two. If true is returned,
            split1 and split2 will be update and reference counted, and var lists are updated
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.Splitter.TryToExtendSplit(System.Int32,System.Int32,System.Int32@,System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Try to include candidate in splitVars, and check if new split is valid.
            If new split is valid, splitToExtend and splitVars are updated
            <param name="root">BDD root of the source BDD</param>
            <param name="candidateFdVar">Variable to attempt to remove from </param>
            <param name="splitToExtend"></param>
            <param name="splitVars"></param>
            <param name="otherSplit"></param>
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.SupportMerger">
            <summary>
            A SupportMerger needs to be initialized with a Noddy instance in constructor. 
            On a subsequent <see cref="M:Configit.Core.Noddy.Algorithms.SupportMerger.Merge(System.Collections.Generic.List{System.Int32},System.Boolean)"/> function call with a set of BDDs as input,
            the input BDDs are merged/conjoined based on matching/subset support variables 
            occurring in the BDDs. 
            This is helpful when attempting to reduce the number of BDDs representing a solution space,
            by allowing BDDs over already existing sets of support variables.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.SupportMerger.Merge(System.Collections.Generic.List{System.Int32},System.Boolean)">
            <summary>
            Merges  (conjoins) BDDs in the input set of BDD roots based on matching occurrence of variables, such that at the end 
            of the merging process no two BDDs have same set of variables when the input parameter "subset" is false.
            If the input parameter "subset" is true, then at the end no two BDDs will occur such that 
            the variables in one BDD is a subset of the other. 
            </summary>
            <param name="roots"> The input list of BDDs represented by root nodes</param>
            <param name="subset"> Specifies whether to merge based on subset variable matching or complete matching</param>
            <returns> Each BDD in the output has a key in the output dictionary, where the matching "value" is corresponding merged set of input BDDs</returns>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.TableStreamBuilder">
            <summary>
            <para>
            Class used for creating a BDD representing a table in disjunctive normal form.</para>
            <para>
            This class will build the tabular data as a balanced binary tree, but make sure
            to disjoin BDDs for rows as soon as possible, to avoid having to keep intermediate
            BDDs for rows references counted (keeping intermediate BDDs for each row
            will take up memory space)
            </para>
            <example>Given a table with multiple rows, the algorithm will disjoin as follows:
            <list type="number">
            <item>res0 = row0 OR row 1</item>
            <item>res1 = row2 OR row 3</item>
            <item>res3 = res1 OR res 2</item>
            <item>res4 = row4 OR row5</item>
            <item>res5 = row6 OR row7</item>
            <item>res6 = res4 OR res5</item>
            <item>res7 = res3 OR res6</item>
            <item>res8 = row8 OR row9</item>
            <item>...</item>
            </list>
            </example>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableStreamBuilder.BuildTable(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Int32}})">
            <summary>
            Build BDD representing the tabular data. Resulting BDD is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableStreamBuilder.BuildTree(System.Collections.Generic.IEnumerator{System.Collections.Generic.IEnumerable{System.Int32}},System.Int32)">
            <summary>
            Build sub-tree.<paramref name="iter"/>
            must be forwarded before calling this method.
            Result IS reference counted!
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.TableToBddConverter">
            <summary>
            Implements linear time conversion from a table of finite domain values to
            its corresponding BDD.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableToBddConverter.Convert(System.Collections.Generic.IEnumerable{System.Int32},System.Int32[][])">
            <summary>
            Build BDD representing the tabular data. Resulting BDD is *not* reference counted.
            <remarks><paramref name="table"/> will be mutated (rows sorted)</remarks>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableToBddConverter.BuildTreeNode(Configit.Core.Noddy.Algorithms.TableToBddConverter.Input,System.Int32,System.Int32,System.Int32)">
            <summary>
            Recursively splits rows into buckets corresponding to nodes in a virtual
            binary tree.
            </summary>
            <param name="req"><see cref="T:Configit.Core.Noddy.Algorithms.TableToBddConverter.Input"/></param>
            <param name="layerIdx">The binary layer we are building, <see cref="T:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer"/></param>
            <param name="startIncl">First row to include in node</param>
            <param name="endExcl">End (exclusive) of rows to include</param>
            <returns>non-reference counted bdd node index</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableToBddConverter.Partition(Configit.Core.Noddy.Algorithms.TableToBddConverter.Input,Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer,System.Int32,System.Int32)">
            <summary>
            Partitions rows based on the current bit location such that 0 entries
            come first, followed by 1 entries.
            </summary>
            <param name="req"><see cref="T:Configit.Core.Noddy.Algorithms.TableToBddConverter.Input"/></param>
            <param name="layer">The <see cref="T:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer"/> we are working on</param>
            <param name="startIncl">First row to partition</param>
            <param name="endExcl">Exclusive upper limit on rows to partition</param>
            <returns>Number of 0 entries found</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableToBddConverter.GetBit(System.Int32,System.Int32)">
            <summary>
            Gets the i'th bit where i = 0 is the least significant.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer">
            <summary>
            Tracks layers at the binary level, keeping
            track of both the current bdd variable, index
            into the binary value in the table cell and the
            table column.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer.ColIdx">
            <summary>
            The table column index (used as _rows[i][pos.ColIdx] )
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer.BitIdx">
            <summary>
            Bit index (0 = least significant) into the table cell values
            in column <see cref="P:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer.ColIdx"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer.BddVar">
            <summary>
            The bdd var used to encode <see cref="P:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer.BitIdx"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableToBddConverter.CreateLayerIndex(System.Int32[])">
            <summary>
            Creates a <see cref="T:Configit.Core.Noddy.Algorithms.TableToBddConverter.BddLayer"/> for each encoding bdd variable. Ordered
            from top to bottom.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.TableToBddConverter.ValidateInput(System.Int32[][],System.Int32[])">
            <summary>
            Validate that the provided table is consistent
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.UnaryConstraintPropagator">
            <summary>
            Merges/Conjoins any constraint over only one variable into any other constraint having that variable.
            This propagates information in single variable constraints to other constraints having such variables.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.UniquelyDefinesCounterExampleMode">
            <summary>
            Defines the behavior of <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.UniquelyDefinesCounterExample(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32},Configit.Core.Noddy.Algorithms.UniquelyDefinesCounterExampleMode)"/>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.UniquelyDefinesCounterExampleMode.None">
            <summary>
            Counter-examples not needed, simply return a non-false bdd if counter-examples exist
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.UniquelyDefinesCounterExampleMode.Some">
            <summary>
            Return at least one counter-example in the returned bdd if one exists.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Algorithms.UniquelyDefinesCounterExampleMode.All">
            <summary>
            Return all counter-examples in the returned bdd if one exists.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm">
            <summary>
            Low-level algorithm for computing an unsat core
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.#ctor(Configit.Core.Noddy.Noddy)">
            <summary>
            Sets up the unsat core algorithm with a given <see cref="T:Configit.Core.Noddy.Noddy"/> instance.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.FindUnsatCore(System.Collections.Generic.IEnumerable{System.Int32},System.Int32,System.Int32)">
            <summary>
            Finds the subset of <paramref name="roots"/> that when conjoined with <paramref name="target"/>
            yields <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddFalse"/>. If <paramref name="preProcessConjoinLimit"/> is set,
            the algorithm will try to pre-conjoin roots when checking for satisfiability. See <see cref="M:Configit.Core.Noddy.Algorithms.Conjoiner.ConjoinWithLimit(System.Collections.Generic.IEnumerable{System.Int32},System.Boolean,System.Collections.Generic.IEnumerable{System.Int32},System.Int32)"/>
            </summary>
            <returns>The subset of the <paramref name="roots"/> that when conjoined with 
            <paramref name="target"/> yields false. If <paramref name="target"/> can be 
            conjoined with all <paramref name="roots"/> without resulting in false, 
            null is returned.</returns>
            <remarks>It is expected that all input roots are reference counted</remarks>
            <exception cref="T:System.ArgumentException">If target is false</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.GrowUntilUnsatCoreFound(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Return roots that when conjoined results in false. Returns the empty 
            set if all roots can be conjoined
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.FindUnsatCoreExtension(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32@,System.Int32)">
            <summary>
            Find root that can when applied to a bunch of other roots tips over and makes the 
            conjunction false. Returns -1 if no conjunction that returns false can be found.
            Searches in intervals, and calls sub-method to find within an interval
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.FindUnsatCoreExtensionInInterval(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32,System.Int32@,System.Int32)">
            <summary>
            All roots in <paramref name="unsatCore"/> between 0 and <paramref name="min"/> can be 
            conjoined without giving false. Find root in index between <paramref name="min"/>
            and <paramref name="max"/> that when applied yields false in the conjunction. 
            If no root can be found, -1 is returned
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.SortRoots(System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.HashSet{System.Int32}})">
            <summary>
            The efficiency of the algorithm depends much on the sequence of the roots.
            The algorithm searches forward, so the search sequence should contain roots
            that are likely to be part of unsat core first in the list
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.SortAffectedRoots(System.Collections.Generic.HashSet{System.Int32},System.Collections.Generic.List{System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.HashSet{System.Int32}})">
            <summary>
            Add all roots that are effected immediately by applying original target
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.SortRootsByFdVariablePropagation(System.Collections.Generic.HashSet{System.Int32},System.Collections.Generic.List{System.Int32})">
            <summary>
            Propagate FD variable domains from root to root. Remove roots from <paramref name="remainingRoots"/>
            and insert into <paramref name="sortedRoots"/> when roots are found to be used in FD variable domain
            propagation.
            </summary>
            <returns>True if sortedRoots have enough to find unsat core</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Algorithms.UnsatCoreAlgorithm.FindValidDomains(System.Collections.Generic.HashSet{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Iterate over all <paramref name="remainingRoots"/>, and see if we can extract a root
            to put on <paramref name="sortedRoots"/>, such that valid domains are restricted.
            Returns BddKernel.BddFalse if we know that <paramref name="sortedRoots"/> has what
            it takes to find an unsat core
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Bdd">
            <summary><para>A BDD represents a Boolean function over a set of Boolean variables.</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.#ctor(System.Int32,Configit.Core.Noddy.Noddy)">
            <summary>
            Do not use directly, called through <see cref="M:Configit.Core.Noddy.Bdd.Create(System.Int32,Configit.Core.Noddy.Noddy)"/>.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Create(System.Int32,Configit.Core.Noddy.Noddy)">
            <summary>
            Creates a live external root for a given node index. Reuses objects when possible.
            Assumes nodeIndex is not reference counted.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Bdd.MaxRef">
            <summary>
            Reference count value indicating that BDD will newer go out of scope. 
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.Noddy">
            <summary>
            The <see cref="T:Configit.Core.Noddy.Noddy"/> instance this BDD belongs to
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.Kernel">
            <summary>
            Kernel used by BDD package
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.BinOperations">
            <summary>
            Binary BDD operations module used by Noddy instance
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Save(System.IO.TextWriter,System.Boolean)">
            <summary>
            Save BDD to writer. BDD is saved normalized and mime encoded. In order
            to be compatible with BDDs saved in legacy VT files <paramref name="legacyBackwardsCompatible"/> 
            must be set to true as finite domain information will otherwise be included.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Save(System.String,System.Boolean)">
            <summary>
            Save BDD to path. BDD is saved normalized and mime encoded. In order
            to be compatible with BDDs saved in legacy VT files <paramref name="legacyBackwardsCompatible"/> 
            must be set to true as finite domain information will otherwise be included.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.PrintAsText(System.String)">
            <summary>
            <para>
            Print the table entries reachable from the root of the BDD. Entries
            are printed as text in the format
            </para>
            <para>Node:Var:Low:High</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.PrintAsText(System.IO.TextWriter)">
            <summary>
            <para>
            Print the table entries reachable from the root of the BDD. Entries
            are printed as text in the format
            </para>
            <para>Node:Var:Low:High</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.PrintAsDot(System.Boolean)">
            <summary>
            Print the BDD in Graphviz format as a directed graph. Output as string
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.PrintAsDot(System.String,System.Boolean)">
            <summary>
            Print the BDD in Graphviz format as a directed graph. Output to 
            specified file
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.PrintAsDot(System.IO.TextWriter,System.Boolean)">
            <summary>
            Print the BDD in Graphviz format as a directed graph
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Split">
            <summary>
            <para>Attempts to split BDD into a set of smaller BDDs that when conjoined yields this BDD. 
            The <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/> of each of the BDDs in the result will be smaller than
            the <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/> for this BDD</para>
            </summary>
            <remarks>The input BDD must be defined over finite domain variables</remarks>
            <returns>The split BDDs that when conjoined equals the input BDD</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            Apply this BDD to another BDD using standard binary operators such as AND, OR etc. This instance
            is used as the left operand, the other BDD is used as the right operand to 
            the operator.
            </summary>
            <param name="other">Right hand argument to logical operator</param>
            <param name="opr">Binary operator that is used to apply left (this) and right (other) together</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.IfThenElse(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            Create Boolean function that evaluates to <paramref name="whenTrue"/> when
            this BDD is true and <paramref name="whenFalse"/>
            when this BDD is false.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.IfThenElse(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            Create Finite Domain Boolean function that evaluates to <paramref name="whenTrue"/> when
            this BDD is true and <paramref name="whenFalse"/>
            when this BDD is false.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ApplyDomainConstraints">
            <summary>
            Apply domain constraints to all finite domain variables mentioned in BDD.
            Applying domain constraints ensures that the BDD does not represent any
            value for any of the finite domain variables that is outside of the 
            declared domain of the finite domain variable.
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.IsDomainConstraintsOnly">
            <summary>
            True if BDD is not <see cref="P:Configit.Core.Noddy.Bdd.IsConst"/> and only represents domain constraints for variables in <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.EnsureSameNoddyInstance(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Noddy@,System.Int32@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary>
            Make sure two BDDs belong to the same Noddy instance. Output node indices and 
            BinaryOperations for common instance. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.And(Configit.Core.Noddy.Bdd)">
            <summary>
            Produce the logical conjunction of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.And"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_BitwiseAnd(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical conjunction of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.And"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Xor(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical exclusive-or of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Xor"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_ExclusiveOr(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical exclusive-or of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Xor"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Or(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical disjunction of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Or"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_BitwiseOr(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical disjunction of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Or"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Nand(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical not-and of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Nand"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Nor(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical not-or of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Nor"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Imp(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical implication of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Imp"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_GreaterThan(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical implication of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Imp"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.BiImp(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical bi-implication of two BDDs - that is, calculate the expression
            representing when two BDDs are equal.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.BiImp"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_Equality(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            <para>
            Calculate the logical bi-implication of two BDDs - that is, calculate the expression
            representing when two BDDs are equal.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.BiImp"/>.
            </para>
            <para>Note that this is NOT the same as comparing if two BDDs are identical! To
            compare two BDDs please use <see cref="M:Configit.Core.Noddy.Bdd.Equals(Configit.Core.Noddy.Bdd)"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_Inequality(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            <para>
            Calculate the negation of the logical bi-implication of two BDDs - that is, calculate the 
            BDD expression representing when two BDDs are not equal.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.BiImp"/> and
            negating the result.
            </para>
            <para>Note that this is NOT the same as comparing if two BDDs are not identical! To
            compare two BDDs please use <see cref="M:Configit.Core.Noddy.Bdd.Equals(Configit.Core.Noddy.Bdd)"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Greater(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical greater-than of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Greater"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Less(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical less-than of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.Less"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.InvImp(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical inverse implication of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.InvImp"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_LessThan(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical inverse implication of two BDDs.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with operator <see cref="F:Configit.Core.Noddy.Operators.BddOpr.InvImp"/>.
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Not">
            <summary>
            Calculate the logical negation of the BDD.
            Negate the BDD by replacing all references to the terminal true with 
            references to the the terminal false and vice versa.
            </summary>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Simplify(Configit.Core.Noddy.Bdd)">
            <summary>
            <para>
            Try to simplify this BDD by "removing" information which is represented
            in the other BDD. The result is a simplified BDD that, when conjoined
            with other, will yield the same result as when other is conjoined with 
            this BDD.</para>
            <para>If the support sets for this BDD and the other BDD are disjoined, 
            the BDD cannot be simplified. In this case, the result is identical to 
            this BDD. It is not guaranteed that the result is smaller than the input.</para>
            <para>This operation is also know as Coudert and Madre's restrict function.</para>
            </summary>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Relax(Configit.Core.Noddy.Bdd)">
            <summary>
            Similar to <see cref="M:Configit.Core.Noddy.Bdd.Simplify(Configit.Core.Noddy.Bdd)"/> but guarantees that the set of solutions to the BDD
            after relax is strictly a superset compared to the original. If the other BDD cuts of a branch,
            the relaxed BDD will accept any solution along that branch.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Restrict(Configit.Core.Noddy.Bdd)">
            <summary>
            <para>Restrict a set of variables to constant values. The BDD representing
            the constants must be a single path BDD. The results of the restrict operation is equivalent
            to conjoining the constants BDD to this BDD followed by an existentially quantifying
            of all variables mentioned in the constants BDD</para>
            <para>The resulting BDD is guaranteed to be of equal or lesser size than the original.</para>
            </summary>
            <param name="constants">Single path BDD representing constant assignments to individual
            BDD variables</param>
            <exception cref="T:System.ArgumentException">If constants is not a single path BDD</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.op_LogicalNot(Configit.Core.Noddy.Bdd)">
            <summary>
            Calculate the logical negation of the BDD.
            Identical to calling <see cref="M:Configit.Core.Noddy.Bdd.Not"/> with the operator
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.SatCount">
            <summary>
            Calculate the number of possible different variable assignments there exist
            such that the BDD is satisfied.
            </summary>
            <exception cref="T:System.ArgumentException">If the argument is an invalid BDD</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.PathCount">
            <summary>
            Calculate the number of satisfying paths through the BDD.
            </summary>
            <exception cref="T:System.ArgumentException">If the argument is an invalid BDD</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.IsSinglePath">
            <summary>
            A BDD is single path if at least one path from every node in the BDD leads to a terminal. A 
            single path BDD thus only have one solution for each of the BDD variables in it's <see cref="P:Configit.Core.Noddy.Bdd.Support"/>
            set. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ExtractSinglePathConstants">
            <summary>
            Constructs a BDD representing the single path consisting of all BDD variable
            constants in the input BDD. I.e. a variable will occur in the resulting
            BDD if all satisfying paths in the input BDD requires the same truth assignment
            to that BDD variable.
            <returns><see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> if BDD has no BDD variable constants, or a <see cref="T:Configit.Core.Noddy.Bdd"/>
            where <see cref="P:Configit.Core.Noddy.Bdd.IsSinglePath"/> is true and contains all constant BDD variables in the
            <see cref="P:Configit.Core.Noddy.Bdd.Support"/></returns>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.NodeCount">
            <summary>
            Calculate the number of non-terminal nodes used to represent the BDD
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.IsConst">
            <summary>
            Returns true if the BDD represents either True or False
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.IsFalse">
            <summary>
            Returns true if the BDD represents False
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.IsTrue">
            <summary>
            Returns true if the BDD represents True
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.Support">
            <summary>
            The set of BDD variables that are mentioned in the BDD. Result
            is sorted by variable order.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.FdVarSupport">
            <summary>
            The finite domain variables encoded by the BDD variables in the <see cref="P:Configit.Core.Noddy.Bdd.Support"/> set. 
            If no finite domain variables have been declared, this property is null.
            Result are sorted by variable order.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Exist(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Existential quantification of BDD variables. Removes all occurrences of BDD variables
            mentioned in the bddVars collection by existential quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="bddVars">Definition of the BDD variables to be removed by
            existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Project(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Helper method that generates the BDD representing the solution space 
            of the current BDD projected onto the provided variables, by removing all other 
            variables using existential quantification. The behavior is the same as 
            calling <see cref="M:Configit.Core.Noddy.Bdd.Exist(System.Collections.Generic.IEnumerable{System.Int32})"/> with all variables except
            those specified in <paramref name="bddVars"/>.
            </summary>
            <param name="bddVars">The variables to project onto.</param>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Exist(System.Int32)">
            <summary>
            <para>Existential quantification of a single BDD variable. Removes all occurrences of BDD variable
            mentioned in the bddVar by existential quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="bddVar">BDD variable to be removed by existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ExistFd(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Existential quantification of <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> variables. 
            Removes all occurrences of BDD variables that are used to encode the finite 
            domain variables 
            mentioned in the fdVars collection by existential quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="fdVars">Definition of the finite domain variables for which 
            their encoding BDD variables are to be removed by existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ExistFd(System.Int32)">
            <summary>
            <para>Existential quantification of <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> variable. 
            Removes all occurrences of BDD variables that are used to encode the finite 
            domain variable mentioned by fdVar by existential quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="fdVar">The finite domain variables for which 
            the encoding BDD variables are to be removed by existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ProjectFd(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Helper method that generates the BDD representing the solution space 
            of the current BDD projected onto the provided variables, by removing all other 
            variables using existential quantification. The behavior is the same as 
            calling <see cref="M:Configit.Core.Noddy.Bdd.ExistFd(System.Collections.Generic.IEnumerable{System.Int32})"/> with all variables except
            those specified in <paramref name="fdVars"/>.
            </summary>
            <param name="fdVars">The variables to project onto.</param>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Forall(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Universal quantification of BDD variables. Removes all occurrences of BDD variables
            mentioned in the bddVars collection by universal quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="bddVars">Definition of the BDD variables to be removed by
            universal quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Forall(System.Int32)">
            <summary>
            <para>Universal quantification of a single BDD variable. Removes all occurrences of BDD variable
            mentioned in the bddVar by universal quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="bddVar">BDD variable to be removed by universal quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ForallFd(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Universal quantification of <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> variables.   
            Removes all occurrences of BDD variables that are used to encode the finite 
            domain variables mentioned in the fdVars collection by universal quantification.
            The resulting BDD contains exactly those solutions that are valid in the input 
            regardless of the value of the removed finite domain variables.</para>
            <para>Domain constraints are not reapplied to result.</para>
            <example>
            Consider a BDD f encoding the following finite variable solutions, assuming each 
            finite domain variable has a domain of size 3:
            <para>x0 x1</para>
            <para>0  0,</para>
            <para>1  *,</para> 
            <para>2  *</para>
            <para>(* indicating any value)</para>
            Applying this method to finite domain variables x0 will produce a BDD
            with the single solution 0 for x1.
            </example>
            <remarks>
            In order to obtain the intersection of solutions across a subset of a variable
            domain simply build a new BDD that is true for the other values in the domain, 
            and pass it into this method and pass in the BDD to examine disjoined with this BDD.
            Consider the previous example. If we want all solutions for x1 where x0=1 and x0=2 are interchangeable,
            we compute (f | x0==0).ForAllFd(x0) which will in this case yield true.
            Furthermore, note that ForallFd( {i,j}, bdd ) is equivalent to ForallFd( {j}, ForAllFd( {i}, bdd ) ).
            </remarks>
            </summary>
            <param name="fdVars">Definition of the finite domain variables for which 
            their encoding BDD variables are to be removed by universal quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ForallFd(System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Noddy.Bdd.ForallFd(System.Collections.Generic.IEnumerable{System.Int32})"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Unique(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Unique quantification of BDD variables. Removes all occurrences of BDD variables
            mentioned in the bddVars collection by unique quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="bddVars">Definition of the BDD variables to be removed by
            unique quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Unique(System.Int32)">
            <summary>
            <para>Unique quantification of a single BDD variable. Removes all occurrences of BDD variable
            mentioned in the bddVar by unique quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="bddVar">BDD variable to be removed by unique quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.UniqueFd(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Unique quantification of <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> variables. 
            Removes all occurrences of BDD variables that are used to encode the finite 
            domain variables 
            mentioned in the fdVars collection by unique quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="fdVars">Definition of the finite domain variables for which 
            their encoding BDD variables are to be removed by unique quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.UniqueFd(System.Int32)">
            <summary>
            <para>Unique quantification of <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> variable. 
            Removes all occurrences of BDD variables that are used to encode the finite 
            domain variable mentioned by fdVar by unique quantification.</para>
            <para>Domain constraints are not reapplied to result. If only a subset of the 
            variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is quantified, the domain
            constraints might no longer be valid.</para>
            </summary>
            <param name="fdVar">The finite domain variables for which 
            the encoding BDD variables are to be removed by unique quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ApplyExist(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Apply <paramref name="other"/> to this BDD instance using <paramref name="opr"/>
            and then perform existential quantification of BDD variables.</para>
            <para>Domain constraints are applied to the result if 
            <see cref="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints"/> is set. 
            If only a subset of the variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is
            quantified, the domain constraints might no longer be valid.
            </para>
            <para>Using this operation is identical to first calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> followed
            by calling <see cref="M:Configit.Core.Noddy.Bdd.Exist(System.Collections.Generic.IEnumerable{System.Int32})"/> but
            is faster than the sum of the two operations. 
            <para>
            </para>
            Note that the cache build up this operation cannot be 
            re-used in subsequent apply operations. As such, this operation should only 
            be used over an apply operation followed by a quant operation in cases 
            where subsequent apply operations would not benefit from a shared cache.
            </para>
            </summary>
            <param name="other">BDD to apply to this BDD instance</param>
            <param name="opr">Apply operator to use</param>
            <param name="bddVars">Definition of the BDD variables to be removed by
            existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ApplyExist(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr,System.Int32)">
            <summary>
            <para>Apply <paramref name="other"/> to this BDD instance using <paramref name="opr"/>
            and then perform existential quantification of BDD variable.</para>
            <para>Domain constraints are applied to the result if 
            <see cref="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints"/> is set. 
            If only a subset of the variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is
            quantified, the domain constraints might no longer be valid.
            <para>Using this operation is identical to first calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> followed
            by calling <see cref="M:Configit.Core.Noddy.Bdd.Exist(System.Int32)"/> but
            is faster than the sum of the two operations.</para>
            </para>
            <para>
            Note that the cache build up this operation cannot be 
            re-used in subsequent apply operations. As such, this operation should only 
            be used over an apply operation followed by a quant operation in cases 
            where subsequent apply operations would not benefit from a shared cache.
            </para>
            </summary>
            <param name="other">BDD to apply to this BDD instance</param>
            <param name="opr">Apply operator to use</param>
            <param name="bddVar">BDD variable to be removed by existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ApplyExistFd(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Apply <paramref name="other"/> to this BDD instance using <paramref name="opr"/>
            and then perform existential quantification of BDD variables used to encode
            specified finite domain variables.</para>
            <para>Domain constraints are applied to the result if 
            <see cref="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints"/> is set. 
            If only a subset of the variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is
            quantified, the domain constraints might no longer be valid.
            <para>Using this operation is identical to first calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> followed
            by calling <see cref="M:Configit.Core.Noddy.Bdd.ExistFd(System.Collections.Generic.IEnumerable{System.Int32})"/> but
            is faster than the sum of the two operations.</para>
            </para>
            <para>
            Note that the cache build up this operation cannot be 
            re-used in subsequent apply operations. As such, this operation should only 
            be used over an apply operation followed by a quant operation in cases 
            where subsequent apply operations would not benefit from a shared cache.
            </para>
            </summary>
            <param name="other">BDD to apply to this BDD instance</param>
            <param name="opr">Apply operator to use</param>
            <param name="fdVars">Definition of the finite domain variables for which 
            their encoding BDD variables are to be removed by existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ApplyExistFd(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr,System.Int32)">
            <summary>
            <para>Apply <paramref name="other"/> to this BDD instance using <paramref name="opr"/>
            and then perform existential quantification of BDD variable used to encode
            specified finite domain variables.</para>
            <para>Domain constraints are applied to the result if 
            <see cref="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints"/> is set. 
            If only a subset of the variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is
            quantified, the domain constraints might no longer be valid.
            <para>This operation is identical to first calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> followed
            by calling <see cref="M:Configit.Core.Noddy.Bdd.ExistFd(System.Int32)"/> but
            is faster than the sum of the two operations.</para>
            </para>
            <para>
            Note that the cache build up this operation cannot be 
            re-used in subsequent apply operations. As such, this operation should only 
            be used over an apply operation followed by a quant operation in cases 
            where subsequent apply operations would not benefit from a shared cache.
            </para>
            </summary>
            <param name="other">BDD to apply to this BDD instance</param>
            <param name="opr">Apply operator to use</param>
            <param name="fdVar">Definition of the finite domain variable for which 
            the encoding BDD variables are to be removed by existential quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ApplyForall(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Apply <paramref name="other"/> to this BDD instance using <paramref name="opr"/>
            and then perform universal quantification of BDD variables.</para>
            <para>Domain constraints are applied to the result if 
            <see cref="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints"/> is set. 
            If only a subset of the variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is
            quantified, the domain constraints might no longer be valid.
            <para>Using this operation is identical to first calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> followed
            by calling <see cref="M:Configit.Core.Noddy.Bdd.Forall(System.Collections.Generic.IEnumerable{System.Int32})"/> but
            is faster than the sum of the two operations.</para>
            </para>
            <para>
            Note that the cache build up this operation cannot be 
            re-used in subsequent apply operations. As such, this operation should only 
            be used over an apply operation followed by a quant operation in cases 
            where subsequent apply operations would not benefit from a shared cache.
            </para>
            </summary>
            <param name="other">BDD to apply to this BDD instance</param>
            <param name="opr">Apply operator to use</param>
            <param name="bddVars">Definition of the BDD variables to be removed by
            universal quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ApplyForall(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr,System.Int32)">
            <summary>
            <para>Apply <paramref name="other"/> to this BDD instance using <paramref name="opr"/>
            and then perform universal quantification of BDD variable.</para>
            <para>Domain constraints are applied to the result if 
            <see cref="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints"/> is set. 
            If only a subset of the variables used for encoding a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> is
            quantified, the domain constraints might no longer be valid.
            <para>Using this operation is identical to first calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> followed
            by calling <see cref="M:Configit.Core.Noddy.Bdd.Forall(System.Int32)"/> but
            is faster than the sum of the two operations.</para>
            </para>
            <para>
            Note that the cache build up this operation cannot be 
            re-used in subsequent apply operations. As such, this operation should only 
            be used over an apply operation followed by a quant operation in cases 
            where subsequent apply operations would not benefit from a shared cache.
            </para>
            </summary>
            <param name="other">BDD to apply to this BDD instance</param>
            <param name="opr">Apply operator to use</param>
            <param name="bddVar">BDD variable to be removed by universal quantification.</param>
            <exception cref="T:System.ArgumentException">If this BDD is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.GetValidValues">
            <summary>
            Find valid values of the finite domain variables. A valid value is a value
            that if assigned to the variable, and the assignment is conjoined on this
            BDD, the result is different from <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>.
            </summary>
            <returns>Enumerable of int arrays of length <see cref="P:Configit.Core.Noddy.Noddy.FdVarCount"/>.
            Each entry representing the valid values of a finite domain variable, or
            null if all values for the variable are valid. All values are valid if eg.
            variable is not in the support set, or if the only information about
            the variable in this BDD is the domain constraint.
            </returns>
            <remarks>The returned values are in ascending order.</remarks>
            <exception cref="T:System.InvalidOperationException">If no finite domain variables have been declared</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.GetValidValues(System.Int32)">
            <summary>
            <para>Find valid values for specified finite domain variable. A valid value is a value
            that if assigned to the variable, and the assignment is conjoined on this
            BDD, the result is different from <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>.</para>
            <para>If only searching for valid values for a single variable, this method
            if faster than calling <see cref="M:Configit.Core.Noddy.Bdd.GetValidValues"/> and extracting the 
            relevant array.</para>
            </summary>
            <returns>null if all values are valid, or an array with valid values. 
            All values are valid if e.g..
            variable is not in the support set, or if the only information about
            the variable in this BDD is the domain constraint.
            </returns>
            <remarks>The returned values are in ascending order.</remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="fdVar"/> is invalid.</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.NodeIndex">
            <summary>
            The index in the BDD node table of the <see cref="P:Configit.Core.Noddy.Bdd.Noddy"/> that holds 
            this BDD instance
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.Low">
            <summary>
            The false branch of a BDD. Result is reference counted.
            </summary>
            <exception cref="T:System.ArgumentException">Throws exception if this BDD is invalid</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.High">
            <summary>
            The true branch of a BDD. Result is reference counted.
            </summary>
            <exception cref="T:System.ArgumentException">Throws exception if this BDD is invalid</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.Var">
            <summary>
            The index of the BDD variable for the root of the BDD.
            </summary>
            <exception cref="T:System.ArgumentException">Throws exception if root not is not a valid BDD</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.FdVar">
            <summary>
            The index of the finite domain variable that the variable <see cref="P:Configit.Core.Noddy.Bdd.Var"/> encodes.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Bdd.RefCount">
            <summary>
            Get the reference count for BDD. If value returned in <see cref="F:Configit.Core.Noddy.Bdd.MaxRef"/> it means
            that the BDD will never go out of scope. 
            </summary>
            <exception cref="T:System.ArgumentException">Throws exception if root not is not a valid BDD</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Equals(Configit.Core.Noddy.Bdd)">
            <summary>
            Check equality with other <see cref="T:Configit.Core.Noddy.Bdd"/> by comparing
            both Noddy instance and <see cref="P:Configit.Core.Noddy.Bdd.NodeIndex"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.Equals(System.Object)">
            <summary>
            Equality of BDD with object. If object is a <see cref="T:Configit.Core.Noddy.Bdd"/> it uses
            <see cref="M:Configit.Core.Noddy.Bdd.Equals(Configit.Core.Noddy.Bdd)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.GetHashCode">
            <summary>
            Hash code of BDD using Noddy instance and <see cref="P:Configit.Core.Noddy.Bdd.NodeIndex"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.CheckRoot">
            <summary>
            Check that BDD is reference counted and that it represents a node in the
            node table which is actually used
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Bdd.ToString">
            <summary>
            Print root number
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.BddEnumerableExtensions">
            <summary>
            Helper extension methods for working with collections of <see cref="T:Configit.Core.Noddy.Bdd"/>s
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.Disjoin(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Create the disjunction of a collection of <see cref="T:Configit.Core.Noddy.Bdd"/>s
            </summary>
            <exception cref="T:System.ArgumentException">If <paramref name="bdds"/> is null or empty</exception>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.Conjoin(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create the conjunction of a collection of <see cref="T:Configit.Core.Noddy.Bdd"/>s. This is done 
            by calling <see cref="N:Configit.Core.Noddy.Algorithms"/> conjoin
            </summary>
            <param name="bdds"><see cref="T:Configit.Core.Noddy.Bdd"/> instances to conjoin</param>
            <param name="privateVars">Optional collection of BDD variables to quantify from the result</param>
            <exception cref="T:System.ArgumentException">If <paramref name="bdds"/> is null or empty</exception>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.TrueCount(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            <para>Get count representing how many of the input BDDs evaluate to true. </para>
            <para>Identical to calling <see cref="M:Configit.Core.Noddy.Algorithms.Algorithms.TrueCount(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/>,
            except this extension cannot accept the empty set of BDDs (which should be identical to FALSE).</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.UniqueNodeCount(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Counts the number of unique nodes in a set of BDDs. Identical to calling
            <see cref="M:Configit.Core.Noddy.Noddy.UniqueNodeCount(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/> with <paramref name="bdds"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.MultiApply(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            Apply multiple BDDs in one operation into a single BDD. Only conjunction 
            (<see cref="F:Configit.Core.Noddy.Operators.BddOpr.And"/>) and disjunction (<see cref="F:Configit.Core.Noddy.Operators.BddOpr.Or"/>) are 
            supported. 
            Identical to calling <see cref="M:Configit.Core.Noddy.Noddy.MultiApply(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},Configit.Core.Noddy.Operators.BddOpr)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.Satisfy(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)">
            <summary>
            Try to find a BDD that satisfies the conjunction of the input BDDs. That is, a BDD that when
            conjoined with all BDDs in <paramref name="bdds"/> does not result in <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>.
            The result might not be identical to the conjunction of the <paramref name="bdds"/>, 
            but might only represent a sub-set of the solutions in the conjunction of the <paramref name="bdds"/>.
            This method should be significantly faster than
            conjoining the BDDs together as it only tries to find a solution instead of all solutions.
            </summary>
            <param name="bdds">BDDs to check.</param>
            <param name="preProcessConjoinLimit">Sets a limit on how large individual BDDs can be produced 
            during preprocessing before searching for a solution. Setting this to zero or less will disable
            the pre-processing.</param>
            <returns>BDD false if no solution exist, otherwise a BDD containing at least one solution</returns>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.IsSatisfiable(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)">
            <summary>
            Check if there exist a solution for the conjunction of the given <paramref name="bdds"/>. 
            This method should be significantly faster than conjoining the BDDs together and checking if the conjunction <see cref="P:Configit.Core.Noddy.Bdd.IsFalse"/>
            </summary>
            <param name="bdds">BDDs to check.</param>
            <param name="preProcessConjoinLimit">Sets a limit on how large individual BDDs can be produced 
            during preprocessing before searching for a solution. Setting this to zero or less will disable
            the pre-processing.</param>
            <returns>True if conjunction does not result in <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>, false otherwise</returns>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.SaveBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.String)">
            <summary>
            <para>Saves a collection of BDDs to a file</para>
            <para>Identical to calling <see cref="M:Configit.Core.Noddy.Noddy.SaveBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.String)"/></para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.SaveBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.IO.TextWriter)">
            <summary>
            <para>Saves a collection of BDDs to a <see cref="T:System.IO.TextWriter"/></para>
            <para>Identical to calling <see cref="M:Configit.Core.Noddy.Noddy.SaveBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.IO.TextWriter)"/></para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.BddEnumerableExtensions.ProcessBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Algorithms.ProcessingStep},System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>
            Process collection of BDDs using specified <paramref name="processingSteps"/>. The processing
            steps will be performed in the specified sequence.
            </summary>
            <remarks>Domain constraints are not applied.</remarks>
            <param name="conjoinLimit">Used with <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.ConjoinWithLimit"/> to control when to terminate
            conjunction. Default is <see cref="F:System.Int32.MaxValue"/> which means all values will be conjoined</param>
            <param name="privateVars">Used with <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.ConjoinWithLimit"/> to remove private variable. Default
            is null meaning no private variables are to be used.</param>
            <param name="skipSplitIfSupersetDoesNotSplit">Used for <see cref="F:Configit.Core.Noddy.Algorithms.ProcessingStep.Split"/> to control 
            if certain BDDs should not be skipped. See <see cref="N:Configit.Core.Noddy.Algorithms"/> split for further details. Default is false.</param>
            <param name="bdds">Collection of <see cref="T:Configit.Core.Noddy.Bdd"/>s to process</param>
            <param name="processingSteps">The processing step that the input BDDs should go through</param>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.Cache`1">
            <summary>
            General non-linked cache that enables insert / lookup of general data.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.Cache`1.#ctor(System.Int32)">
            <summary>
            Initialize cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.Cache`1.Data">
            <summary>
            All entries in cache
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.Cache`1.Reset">
            <summary>
            Reset / Re-initialize cache
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.BddCacheData2Keys">
            <summary>
            Entry in cache table with 2 keys. Keys are integer and result is an int
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData2Keys.Matches(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Check if keys matches values. Return res as output parameter
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData2Keys.CacheValues(System.Int32,System.Int32,System.Int32)">
            <summary>
            Remember values for later cache entry
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.BddCacheData3Keys">
            <summary>
            Entry in cache table with 3 keys. Keys are integer and result is either an
            int or a double. The int and the double value share the same memory,
            so only one of the entries can be used.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData3Keys.Matches(System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Check if keys matches values. Return res as output parameter
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData3Keys.Matches(System.Int32,System.Int32,System.Int32,System.Double@)">
            <summary>
            Check if keys matches values. Return res as output parameter
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData3Keys.CacheValues(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Remember values for later cache entry
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData3Keys.CacheValues(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Remember values for later cache entry
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.BddCacheData4Keys">
            <summary>
            Entry in cache table with 3 keys. Keys are integer and result is either an
            int or a double. The int and the double value share the same memory,
            so only one of the entries can be used.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData4Keys.Matches(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Check if keys matches values. Return res as output parameter
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheData4Keys.CacheValues(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Remember values for later cache entry
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.BddCacheDataMultiKeys">
            <summary>
            Entry in cache with multiple keys. Used for multi apply
            operations
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheDataMultiKeys.Matches(System.Int32[],System.Int32,System.Int32,System.Int32@)">
            <summary>
            Check if keys matches values. Return res as output parameter
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.BddCacheDataMultiKeys.CacheValues(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Remember values for later cache entry
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.CacheManager">
            <summary>
            Manager of all the different cache types. Caches are created on a 
            need-to-have basis, meaning if you don't use certain operations,
            you don't pay for their cache
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.#ctor(Configit.Core.Noddy.Kernel.BddKernel,System.Int32,System.Int32)">
            <summary>
            Whenever a cache is needed, the cache manager will initialize the cache.
            The size of the caches depends on 
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.CacheManager.MinCacheSize">
            <summary>
            Minimum size of cache table
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.CacheManager.CacheRatio">
            <summary>
            Ratio in percentage between number of nodes in BDD table
            and number of nodes in cache table. If set to 0, cache tables is 
            not resized
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.CacheManager.CacheSize">
            <summary>
            Actual current size of caches tables
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.CacheManager.ApplyCache">
            <summary>
            Apply cache used for Apply and Not
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.CacheManager.MiscCache">
            <summary>
            Cache used for misc operations, such as sat count. 3rd key should be the 
            operation used, represented as a <see cref="T:Configit.Core.Noddy.Operators.OtherBddOpr"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.CacheManager.QuantAndRestrictCache">
            <summary>
            Cache used for quantification and restriction operations
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.GetMultiApplyCache(System.Int32)">
            <summary>
            Getter for multi apply cache. Called with root count, which is used 
            to size the cache
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.ResetMultiApplyCache">
            <summary>
            After a multi apply operation we expect to clear the multi apply 
            cache
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.ApplyHash(System.Int32,System.Int32,System.Int32)">
            <summary>
            Hash for apply operations
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.RootHash(System.Int32)">
            <summary>
            Hash for operations that only looks at a single root
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.QuantAndRestrictHash(System.Int32,System.Int32)">
            <summary>
            Hash for quantification/restrict operation
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.ApplyAndQuantifyHash(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Hash for combined apply and quantify
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.MultiApplyHash(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Hash used for multi apply operations. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.ResetAll">
            <summary>
            Reset all caches. This is typically called by a call from the
            kernel garbage collector
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.RequiredCacheSize">
            <summary>
            Internal calculation of how big the cache need to be
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.CacheManager.CacheSizeChange">
            <summary>
            Called when BDD node table has been resized, or when the <see cref="P:Configit.Core.Noddy.Cache.CacheManager.MinCacheSize"/>
            or <see cref="P:Configit.Core.Noddy.Cache.CacheManager.CacheRatio"/> has changed.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.EnumerableIntCache">
            <summary>
            Cache that stores Enumerable of ints byu 
            an integer key. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.EnumerableIntCache.Insert(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Insert values into cache
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.EnumerableIntCache.Lookup(System.Int32)">
            <summary>
            Lookup in cache for specified key. If entry does not exist,
            null is returned
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.EnumerableIntCache.CachedValueSize(System.Int32)">
            <summary>
            Return the number of values cached for specified key, or
            -1 if no values are cached
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.EnumerableIntCache.PruneCache(System.Func{System.Int32,System.Boolean})">
            <summary>
            Only keep entries in cache for which the key is still
            alive as specified in <paramref name="isAlive"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.EnumerableIntCache.FetchValues(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Retrieves values from specified store
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.IInitializableCacheData">
            <summary>
            Interface implemented by cached data that must be initialized 
            before being put in cache table
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Cache.MultiOperationCache">
            <summary>
            <para>
            Cache holding intermediate results for various operations. The cache can be 
            used when repeatedly processing on a set of BDDs to avoid repeating 
            the same operations on the same BDDs. Most operations in 
            <see cref="P:Configit.Core.Noddy.Noddy.Algorithms"/> support the usage of this type of caching.
            </para>
            <para>If the internal <see cref="T:Configit.Core.Noddy.Noddy"/> garbage collector is called, the
            cache will automatically be pruned. After the garbage 
            collection has finished, only live <see cref="T:Configit.Core.Noddy.Bdd"/> instances will
            remain in this cache. This cache does not keep the 
            <see cref="T:Configit.Core.Noddy.Bdd"/> or <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> instances that it knows
            about alive.</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.MultiOperationCache.#ctor(Configit.Core.Noddy.Noddy)">
            <summary>
            Create multi operation cache for a specific <see cref="T:Configit.Core.Noddy.Noddy"/> instance.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.MultiOperationCache.NodeCountCache">
            <summary>
            Used for <see cref="M:Configit.Core.Noddy.Kernel.BinaryOperations.NodeCount(System.Int32)"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.MultiOperationCache.SupportCache">
            <summary>
            Used for <see cref="P:Configit.Core.Noddy.Bdd.Support"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.MultiOperationCache.FdSupportCache">
            <summary>
            Used for <see cref="P:Configit.Core.Noddy.Bdd.FdVarSupport"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.MultiOperationCache.BddThatCannotBeSplit">
            <summary>
            Used by <see cref="M:Configit.Core.Noddy.Algorithms.Splitter.Split(System.Int32)"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.MultiOperationCache.BddSimplifyThatDoesNotMinimize">
            <summary>
            Used by <see cref="M:Configit.Core.Noddy.Algorithms.Simplifier.SimplifyOrRelaxWithTracking(System.Collections.Generic.IEnumerable{System.Int32},Configit.Core.Noddy.Operators.OtherBddOpr,System.Boolean)"/> to remember which BDD pairs that
            did not result in a smaller BDD
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.MultiOperationCache.BddNeighborSyncCache">
            <summary>
            Used by <see cref="T:Configit.Core.Noddy.Algorithms.NeighborSynchronizer"/> sync methods to cache NeighborSync results
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Cache.MultiOperationCache.BddThatHasNoConstants">
            <summary>
            BDDs that for which <see cref="M:Configit.Core.Noddy.Kernel.BinaryOperations.ExtractSinglePathConstants(System.Int32)"/>
            is known to yield true
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.MultiOperationCache.GetIntHashSet">
            <summary>
            Get an empty int HashSet that has already been allocated
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Cache.MultiOperationCache.RecycleIntHashSet(System.Collections.Generic.HashSet{System.Int32})">
            <summary>
            Return set to pool for later usage
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Events.GarbageCollectionBeginHandler">
            <summary>
            Delegate defining event handlers called when garbage collection starts
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Events.GarbageCollectionEndHandler">
            <summary>
            Delegate defining event handlers called when garbage collection ends
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Events.ConjoinProgressHandler">
            <summary>
            Delegate defining event handlers called each time <see cref="N:Configit.Core.Noddy.Algorithms"/> conjoins two
            BDDs into one
            </summary>
            <param name="noddy">The Noddy instance performing the operation</param>
            <param name="leftArgSize">BDD node count on left argument</param>
            <param name="rightArgSize">BDD node count on right argument</param>
            <param name="resultSize">BDD node count on result of the conjunction</param>
            <param name="queueSize">Number of BDDs in queue awaiting to be conjoined</param>
            <param name="remainingPrivateVars">Number of private variables that are still used in the BDDs in the queue</param>
        </member>
        <member name="T:Configit.Core.Noddy.Events.BddTableResizeHandler">
            <summary>
            Delegate defining event handlers called each time the internal BDD node table
            is resized. 
            </summary>
            <param name="noddy">The <see cref="T:Configit.Core.Noddy.Noddy"/> instance performing the operation</param>
            <param name="oldSize">Number of BDD nodes in table before resize</param>
            <param name="newSize">Number of BDD nodes in after before resize</param>
            <param name="freeNodes">Number of free nodes after resize</param>
        </member>
        <member name="T:Configit.Core.Noddy.Events.SplitProgressHandler">
            <summary>
            Delegate defining event handlers called on Split progress
            </summary>
            <param name="noddy">The <see cref="T:Configit.Core.Noddy.Noddy"/> instance performing the operation</param>
            <param name="current">Number of BDDs processed so far</param>
            <param name="total">Total number of BDDs to process</param>
            <param name="splitBddsSoFar">Number of BDDs generated so far</param>
        </member>
        <member name="T:Configit.Core.Noddy.Events.ReachedMaxNodesHandler">
            <summary>
            <para>Delegate defining event handlers called when an internal operation tries to create a new 
            BDD node, but the table has grown to the maximum allowed size set in <see cref="P:Configit.Core.Noddy.Noddy.MaxNodeSize"/></para>
            <para>Note that this event might be raised multiple times during a single Noddy
            operation.</para>
            </summary>
            <param name="noddy">The Noddy instance performing the operation</param>
            <param name="nodeTableSize">The number of nodes allowed in the BDD node table</param>
        </member>
        <member name="T:Configit.Core.Noddy.Events.SimplifyRelaxProgressHandler">
            <summary>
            Delegate defining event handlers called on <see cref="N:Configit.Core.Noddy.Algorithms"/> simplify and <see cref="N:Configit.Core.Noddy.Algorithms"/>
            relax
            </summary>
            <param name="noddy">The <see cref="T:Configit.Core.Noddy.Noddy"/> instance performing the operation</param>
            <param name="current">The number of BDDs processed</param>
            <param name="total">Total number of BDDs to process</param>
        </member>
        <member name="T:Configit.Core.Noddy.Events.EventRegistrator">
            <summary>
            Access for registering event handlers to follow progress of Noddy work.
            Weak references are used, so registering an event handler will not keep 
            the object owning the event handler alive.
            </summary>
        </member>
        <member name="E:Configit.Core.Noddy.Events.EventRegistrator.OnGarbageCollectBegin">
            <summary>
            Event occurring when a garbage collection begins
            </summary>
        </member>
        <member name="E:Configit.Core.Noddy.Events.EventRegistrator.OnGarbageCollectEnd">
            <summary>
            Event occurring when a garbage collection has ended
            </summary>
        </member>
        <member name="E:Configit.Core.Noddy.Events.EventRegistrator.OnConjoin">
            <summary>
            Event occurring when <see cref="P:Configit.Core.Noddy.Noddy.Algorithms"/> conjoins two BDDs into one
            </summary>
        </member>
        <member name="E:Configit.Core.Noddy.Events.EventRegistrator.OnBddTableResize">
            <summary>
            Event occurring when the internal BDD table is resized. This might happen after
            a garbage collection
            </summary>
        </member>
        <member name="E:Configit.Core.Noddy.Events.EventRegistrator.OnReachedMaxNodes">
            <summary>
            <para>Event occurring when a new node is created but there the internal node table
            has reached it's maximum size defined in <see cref="P:Configit.Core.Noddy.Noddy.MaxNodeSize"/>.
            This event might follow a garbage collection.</para>
            <para>Note that this event might be raised several times during a single Noddy operation.</para>
            </summary>
        </member>
        <member name="E:Configit.Core.Noddy.Events.EventRegistrator.OnSplitProgress">
            <summary>
            Raised during <see cref="N:Configit.Core.Noddy.Algorithms"/> Split method containing information about progress
            </summary>
        </member>
        <member name="E:Configit.Core.Noddy.Events.EventRegistrator.OnSimplifyRelaxProgress">
            <summary>
            Raised during <see cref="N:Configit.Core.Noddy.Algorithms"/> Simplify and <see cref="N:Configit.Core.Noddy.Algorithms"/> Relax methods
            containing information about progress.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Events.NamespaceDoc">
            <summary>
            Access to events raised when performing operations on <see cref="T:Configit.Core.Noddy.Bdd"/>s. This is most often used
            when processing large sets of <see cref="T:Configit.Core.Noddy.Bdd"/>s, e.g. during compilation or heavy analysis phases
            involving multiple BDD operations.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Events.WeakEvent`1">
            <summary>
            A class for managing a weak event.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Events.WeakEvent`1.Add(`0)">
            <summary>
            Add event handler
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Events.WeakEvent`1.RemoveDeadEntries">
            <summary>
            Remove all dead entries
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Events.WeakEvent`1.Remove(`0)">
            <summary>
            Remove event handle from event
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Events.WeakEvent`1.Raise(System.Object[])">
            <summary>
            Raise event for all handlers.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.FdValues">
            <summary>
            Represent a set of values for a finite domain variable
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValues.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates representation of a disjunction of values for a given variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValues.#ctor(System.Int32,System.Int32)">
            <summary>
            Create representation of a single value for a given variable.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FdValues.Variable">
            <summary>   
            Index of finite domain variable
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FdValues.Values">
            <summary>
            Collection of value indices for <see cref="P:Configit.Core.Noddy.FdValues.Variable"/>, or null used to represent
            the collection of all values for <see cref="P:Configit.Core.Noddy.FdValues.Variable"/>
            <remarks>
            Indices are sorted in ascending order
            </remarks>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FdValues.IsDisjunction">
            <summary>
            True if more than one value included.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValues.Equals(System.Object)">
            <summary>
            Return true if <paramref name="other"/> is identical to this set of values
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Configit.Core.Noddy.FdValues.GetHashCode">
            <summary>
            Get hash code for set of values
            </summary>
            <returns></returns>
        </member>
        <member name="M:Configit.Core.Noddy.FdValues.Equals(Configit.Core.Noddy.FdValues)">
            <summary>
            Return true if <paramref name="other"/> is identical to this set of values
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValues.ToString">
            <summary>
            Get string representation for debug purposes
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.FdValuesCollection">
            <summary>
            Represents a collection of <see cref="T:Configit.Core.Noddy.FdValues"/> indexed by variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValuesCollection.#ctor(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.FdValues})">
            <summary>
            Creates an indexed collection from a set of <see cref="T:Configit.Core.Noddy.FdValues"/>.
            </summary>
            <param name="fdValues">List of <see cref="T:Configit.Core.Noddy.FdValues"/> for distinct variables.</param>
        </member>
        <member name="M:Configit.Core.Noddy.FdValuesCollection.ContainsVariable(System.Int32)">
            <summary>
            Checks if an <see cref="T:Configit.Core.Noddy.FdValues"/> exists for the given variable.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FdValuesCollection.Variables">
            <summary>
            Enumerates the variables for which <see cref="T:Configit.Core.Noddy.FdValues"/> are stored.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FdValuesCollection.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Configit.Core.Noddy.FdValues"/> for a given variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValuesCollection.GetEnumerator">
            <summary>
            Get enumerator over all <see cref="T:Configit.Core.Noddy.FdValues"/> in collection
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValuesCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator over all <see cref="T:Configit.Core.Noddy.FdValues"/> in collection
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValuesCollection.Equals(Configit.Core.Noddy.FdValuesCollection)">
            <summary>
            True if <paramref name="other"/> has the exact same values by 
            variable in its collection
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FdValuesCollection.GetHashCode">
            <summary>
            Get hash code for all values in collection
            </summary>
            <returns></returns>
        </member>
        <member name="T:Configit.Core.Noddy.FiniteDomain.BddFd">
            <summary>
            <para>
            BDDs representing functions over finite domain variables. A BddFd is internally 
            represented as a 32 bit BDD vector representing signed binary encoded numbers. 
            Arithmetic functions are performed using 2's complement allowing for graceful
            handling of operation overflow  and intermediate negative number values. 
            <para>The BDDs used for encoding a BddFd must be reference counted using
            <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.IncRef(System.Int32)"/> and <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.DecRef(System.Int32)"/> analogously with handling reference
            counting for <see cref="T:Configit.Core.Noddy.Bdd"/>s.</para>
            </para>
            <para>When operating on BddFds it is important to note, that the operator 
            <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Equality(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)"/>
            is an operation that returns a <see cref="T:Configit.Core.Noddy.Bdd"/> (bi-implication on all BDDs encoding the BddFd),
            where the <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Equals(System.Object)"/> method will check for equality of all BDDs 
            used for encoding the two BddFds
            </para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.GetHashCode">
            <summary>
            Hash of BddFd
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.#ctor(System.Int32[],Configit.Core.Noddy.Noddy)">
            <summary>
            Create new finite domain expression belonging to specific <see cref="P:Configit.Core.Noddy.FiniteDomain.BddFd.Noddy"/> instance
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Create(System.Int32[],Configit.Core.Noddy.Noddy)">
            <summary>
            Creates a live external fd root for a given list of roots
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.BddFd.Noddy">
            <summary>
            The <see cref="P:Configit.Core.Noddy.FiniteDomain.BddFd.Noddy"/> instance this BddFd belongs to
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.BddFd.Kernel">
            <summary>
            Kernel used by Bdd package
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.BddFd.FdOperations">
            <summary>
            Finite domain operations module used by Noddy instance
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.BddFd.Bdds">
            <summary>
            Array of Bdds used to encode finite domain expression
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.IncRef(System.Int32)">
            <summary>
            Increase the reference count for all Bdds used to encode this finite domain expression.
            If the reference count of a BDD is > 0, the BDD
            will not be cleaned when the internal BDD garbage collection is run. Remember 
            to call <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.DecRef(System.Int32)"/> when BddFd is no longer used.
            </summary>
            <param name="count">Increment the ref count by count. Default is 1</param>
            <returns>This object</returns>
            <exception cref="T:System.ArgumentException">Throws exception if any Bdd used for encoding is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.DecRef(System.Int32)">
            <summary>
            Decrement reference count for all Bdds used to encode this finite domain expression.
            If reference count of a Bdd becomes 0, it's Bdd node  will be re-used upon next
            internal Bdd garbage collection.
            </summary>
            <returns>This object</returns>
            <param name="count">Increment the ref count by count. Default is 1</param>
            <exception cref="T:System.ArgumentException">Throws exception if any Bdd used for encoding is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)">
            <summary>
            <para>
            Compare this BddFd with another BddFd, and represent the result as a BDD. Comparisons
            supported are operators such as equals, different, less, greater than etc.
            </para>
            </summary>
            <param name="other">Right hand argument of the comparison operator</param>
            <param name="opr">Operator that is used to compare left (this) and right (other) with each other</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.CalculateShift(System.Int32,Configit.Core.Noddy.Operators.FddCalcOpr)">
            <summary>
            Calculate the result of shifting a BddFd.
            </summary>
            <param name="arg">Number of bits to shift</param>
            <param name="opr">Shift operator to use</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.Operators.FddCalcOpr)">
            <summary>
            Calculate the result of applying the specified unary operator on
            a BddFd. Unary operator supported are: negation
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)">
            <summary>
            Calculate the result of applying the specified binary arithmetic operator on two BddFds. 
            Arithmetic operators are <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Add"/>, <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Sub"/>, and <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Mult"/>
            </summary>
            <param name="other">Right hand argument of the arithmetic operator</param>
            <param name="opr">Arithmetic operator that is used to apply the left (this) and the right(other) together</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.EnsureInSpecifiedNoddyInstance(Configit.Core.Noddy.Noddy,Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32[]@)">
            <summary>
            Make sure <paramref name="moveCandidate"/> belongs to <paramref name="noddy"/> instance.
            If it doesn't, the BDDs in <paramref name="moveCandidate"/> are moved to specified
            <see cref="P:Configit.Core.Noddy.FiniteDomain.BddFd.Noddy"/> instance.
            </summary>
            <returns>
            True if other is moved into specified Noddy instance, false if they
            already belonged to that instance.
            Note: The roots in <paramref name="bddsInThisInstance"/> are reference counted
            if they are moved.
            </returns>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.BiImp(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>
            BDD representing the result of the equality comparison of left and right. This is 
            equivalent to the conjunction of calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with <see cref="F:Configit.Core.Noddy.Operators.BddOpr.BiImp"/>
            on all the BDDs used for encoding the two BddFds. </para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Equal"/></para>
            </summary>
            <param name="other">The BddFd that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Equality(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>
            Bdd representing the result of the equality comparison of left and right. This is 
            equivalent to the conjunction of calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with <see cref="F:Configit.Core.Noddy.Operators.BddOpr.BiImp"/>
            on all the Bdds used for encoding the two BddFds.</para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Equal"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Equality(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>Bdd representing the result of the equality comparison of left and a constant value. This is 
            equivalent to the conjunction of calling <see cref="M:Configit.Core.Noddy.Bdd.Apply(Configit.Core.Noddy.Bdd,Configit.Core.Noddy.Operators.BddOpr)"/> with <see cref="F:Configit.Core.Noddy.Operators.BddOpr.BiImp"/>
            on all the Bdds used for encoding the two BddFds. </para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Equal"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_GreaterThan(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>
            Bdd representing the result of the greater than comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Gt"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_GreaterThan(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>
            Bdd representing the result of the greater than comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Gt"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_GreaterThanOrEqual(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>
            Bdd representing the result of the greater than or equal comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.GtEq"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_GreaterThanOrEqual(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>
            Bdd representing the result of the greater than or equal comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.GtEq"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_LessThan(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>
            Bdd representing the result of the less than comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Lt"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_LessThan(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>
            Bdd representing the result of the less than comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Lt"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_LessThanOrEqual(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>
            Bdd representing the result of the less than or equal comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.LtEq"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_LessThanOrEqual(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>
            Bdd representing the result of the less than or equal comparison of left and right. 
            The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.LtEq"/></para>
            </summary>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Diff(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            Bdd representing the result comparing two BddFd for equality, and negating the result.
            This is equivalent to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.BiImp(Configit.Core.Noddy.FiniteDomain.BddFd)"/> and negating the result.
            </summary>
            <param name="other">The other BddFd that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Inequality(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            Bdd representing the result comparing two BddFd for equality, and negating the result.
            This is equivalent to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.BiImp(Configit.Core.Noddy.FiniteDomain.BddFd)"/> and negating the result.
            </summary>
            <param name="left">Left hand side argument to the comparison operator</param>
            <param name="right">Right hand side argument to the comparison operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Inequality(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            Bdd representing the result comparing one BddFd with a constant value checking for equality,
            and negating the result. This is equivalent to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.BiImp(Configit.Core.Noddy.FiniteDomain.BddFd)"/> and negating the result.
            </summary>
            <param name="left">Left hand side argument to the comparison operator</param>
            <param name="value">Right hand side argument to the comparison operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Lt(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Bdd representing the result of the less comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side smaller than the right hand side.</para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Lt"/></para>
            </summary>
            <param name="other">The BddFd that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Lt(System.Int32)">
            <summary>
            <para>Bdd representing the result of the less comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side smaller than the right hand side.</para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Lt"/></para>
            </summary>
            <param name="value">The constant value that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.LtEq(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Bdd representing the result of the less-equal comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side smaller than or equal the right hand side.</para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.LtEq"/></para>
            </summary>
            <param name="other">The BddFd that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.LtEq(System.Int32)">
            <summary>
            <para>Bdd representing the result of the less-equal comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side smaller than or equal the right hand side.</para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.LtEq"/></para>
            </summary>
            <param name="value">The constant value that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Gt(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Bdd representing the result of the greater comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side greater than the right hand side.</para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Gt"/></para>
            </summary>
            <param name="other">The BddFd that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Gt(System.Int32)">
            <summary>
            <para>Bdd representing the result of the greater comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side greater than the right hand side.</para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.Gt"/></para>
            </summary>
            <param name="value">The constant that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.GtEq(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Bdd representing the result of the greater-equal comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side greater or equal than the right hand side.
            </para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.GtEq"/></para>
            </summary>
            <param name="other">The BddFd that this instance is compared to</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.GtEq(System.Int32)">
            <summary>
            <para>Bdd representing the result of the greater-equal comparison of left and right. The 
            resulting Bdd represents all truth assignments that makes the left hand
            side greater or equal than the right hand side.
            </para>
            <para>The result is identical to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCompOpr.GtEq"/></para>
            </summary>
            <param name="value">The contant value that BddFd is compared with</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Add(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Calculate the result of adding two <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s. </para>
            <para>The result is identical  to calling 
            <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Add"/></para>
            </summary>
            <param name="other">The BddFd that is added to this instance</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Addition(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Calculate the result of adding two <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s. </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Add"/></para>
            </summary>
            <param name="left">Left operand to the operator</param>
            <param name="right">Right operand to the operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Addition(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>Calculate the result of adding a constant value to a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s. </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Add"/></para>
            </summary>
            <param name="left">Left operand to the operator</param>
            <param name="value">Right operand to the operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Sub(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Calculate the result of subtracting one <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> from another. </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Sub"/></para>
            </summary>
            <param name="other">The BddFd that is subtracted from  this instance</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Subtraction(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Calculate the result of subtracting one <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> from another. </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Sub"/></para>
            </summary>
            <param name="left">Left hand operand to the operator</param>
            <param name="right">Right hand operand to the operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Subtraction(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>Calculate the result of subtracting a constant value from  a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/></para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Sub"/></para>
            </summary>
            <param name="left">Left hand operand to the operator</param>
            <param name="value">Right hand operand to the operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Mult(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Calculate the result of multiplying two <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s. </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Mult"/></para>
            </summary>
            <param name="other">The BddFd that is multiplied to this instance</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Multiply(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            <para>Calculate the result of multiplying two <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s. </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Mult"/></para>
            </summary>
            <param name="left">Left hand argument to the operator</param>
            /// <param name="right">right hand argument to the operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_Multiply(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>Calculate the result of multiplying a <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s with a constant value. </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Calculate(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.Mult"/></para>
            </summary>
            <param name="left">left hand argument to the operator</param>
            /// <param name="value">right hand argument to the operator</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.ShiftL(System.Int32)">
            <summary>
            <para>Calculate the result of shifting all Bdds encoding <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s count
            positions to the left, shifting in BddFalse from the right </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.CalculateShift(System.Int32,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.ShiftLeft"/></para>
            </summary>
            <param name="count">The number of places the Bdds encoding this BddFd are shifted</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_LeftShift(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>Calculate the result of shifting all Bdds encoding <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s count
            positions to the left, shifting in BddFalse from the right </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.CalculateShift(System.Int32,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.ShiftLeft"/></para>
            </summary>
            <param name="bddfd">The BddFd for which the Bdds are being shifted</param>
            <param name="count">The number of places the Bdds encoding this BddFd are shifted</param>    
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.ShiftR(System.Int32)">
            <summary>
            <para>Calculate the result of shifting all Bdds encoding <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s count
            positions to the right, shifting in BddFalse from the left </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.CalculateShift(System.Int32,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.ShiftRight"/></para>
            </summary>
            <param name="count">The number of places the Bdds encoding this BddFd are shifted</param>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_RightShift(Configit.Core.Noddy.FiniteDomain.BddFd,System.Int32)">
            <summary>
            <para>Calculate the result of shifting all Bdds encoding <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s count
            positions to the right, shifting in BddFalse from the left </para>
            <para>The result is identical  to calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.CalculateShift(System.Int32,Configit.Core.Noddy.Operators.FddCalcOpr)"/> with operator
            <see cref="F:Configit.Core.Noddy.Operators.FddCalcOpr.ShiftRight"/></para>
            </summary>
            <param name="bddfd">The BddFd for which the Bdds are being shifted</param>
            <param name="count">The number of places the Bdds encoding this BddFd are shifted</param>    
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Negate">
            <summary>
            Calculate the result of negating the value represented by this <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>.
            In 2's complement, negation is done by inverting all the bits and adding one.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.op_UnaryNegation(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            Calculate the result of negating the value represented by this <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>.
            In 2's complement, negation is done by inverting all the bits and adding one.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Equals(Configit.Core.Noddy.FiniteDomain.BddFd)">
            <summary>
            Eqality of two finite domain variables. Compares Noddy instance and
            each Bdd in the encoding
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.Equals(System.Object)">
            <summary>
            Equality of finite domain variable with object. If object is <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>
            then <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Equals(Configit.Core.Noddy.FiniteDomain.BddFd)"/> is used.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.BddFd.CheckRoot">
            <summary>
            Check that all bdd are reference counted and that they represents a node in the
            node table which is actually used
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.FiniteDomain.FdEncodingInfo">
            <summary>
            Struct use for holding information about how finite domain variables are 
            encoded. Used for mapping a given Bdd variable to the fd variable it encodes
            and give information about the bit in the domain that it encodes.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdEncodingInfo.EncodingBit">
            <summary>
            Number of the encoding bit [0;31]. 0 is the least significant
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.FiniteDomain.FdOperations">
            <summary>
            Operators on finite domain variables
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.FiniteDomain.FdOperations.FdEncodingSize">
            <summary>
            Number of Bdd variables used to encode a single finite domain variable
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.FiniteDomain.FdOperations.MaxDomainSize">
            <summary>
            Maximum allowed size of a finite domain variable
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarInfo">
            <summary>
            Information about each fd variable. FdVarInfo is null if no finite domain 
            variables has been specified
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarCount">
            <summary>
            Number of declared finite domains. -1 if no FD variables are declared
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.TotalDomainSum">
            <summary>
            Sum of size of all domains
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.BddVarToEncoding">
            <summary>
            Map from BDD var to info about what it encodes
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.ApplyDomainConstraints">
            <summary>
            Auto apply domain constraints to BDDs
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Calculate(System.Int32[],System.Int32,Configit.Core.Noddy.Operators.FddCalcOpr)">
            <summary>
            Create BddFd representing applying the arithmetic operator to a BddFd.
            This methods only supports operations that support an integer as right hand operands,
            such as shift left and shift right.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Calculate(System.Int32[],System.Int32[],Configit.Core.Noddy.Operators.FddCalcOpr)">
            <summary>
            Create BddFd representing applying the arithmetic operator to two BddFds
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Calculate(System.Int32[],Configit.Core.Noddy.Operators.FddCalcOpr)">
            <summary>
            Create BddFd representing applying unary operator to BddFd
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Compare(System.Int32[],System.Int32[],Configit.Core.Noddy.Operators.FddCompOpr,System.Boolean)">
            <summary>
            Create BDD representing comparison of two BddFds. 
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.TrueCount(System.Collections.Generic.List{System.Int32})">
            <summary>
            Create count representing how many of the input roots evaluate to true
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.IncRef(System.Int32[],System.Int32)">
            <summary>
            Increment reference count for all Bdds encoding BddFd
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.DecRef(System.Int32[],System.Int32)">
            <summary>
            Decrement reference count for all Bdds encoding BddFd
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.FiniteVarDomains">
            <summary>
            Domain sizes of the finite domain variables. Each domain size represented the number
            of different values in the domain (index of first value is 0).
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FiniteVarDomain(System.Int32)">
            <summary>
            Domain size of specific finite domain variable. 
            </summary>
            <exception cref="T:System.InvalidOperationException">If no FD variables are defined</exception>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.AllDomainConstraints">
            <summary>
            BDDs representing domain constraints. Domain constraints should not be included 
            when calling <see cref="M:Configit.Core.Noddy.Noddy.GetReferenceCountedRoots"/> to figure out which BDDs
            are reference counted (used for debug)
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.DomainConstraints">
            <summary>
            BDDs for individual FD variable domain constraints
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdOperations.ConjoinedDomainConstraints">
            <summary>
            Conjunction of all domain constraints. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVar(System.Int32)">
            <summary>
            Get <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> representing the i'th finite domain variable
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdConst(System.Int32,System.Int32[])">
            <summary>
            Get encoding representing a constant value.
            Result need not be reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdConstAssignment(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create Bdd representing assignment of const value to finite domain variable. Result is
            not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdConstAssignments(System.Int32[])">
            <summary>
            Create Bdd representing assignment of constant values to a set of FD variables. Result
            is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdConstAssignments(Configit.Core.Noddy.FdValues,System.Int32)">
            <summary>
            Create Bdd representing assignment of constant values to a single FD variable. Result
            is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdConstAssignments(Configit.Core.Noddy.FdValues[])">
            <summary>
            Create BDD representing assignment of constant values to FD variables. Result
            is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Equality(System.Int32[],System.Int32[])">
            <summary>
            Conjoin the bit-wise equality of all Bdds used to encode left and right
            Note: it is assumed that left and right are reference counted before call.
            The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Negation(System.Int32[],System.Int32[])">
            <summary>
            Negate argument
            Note: is is assumed that left and right are reference counted before call.
            The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Addition(System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Add two BddFds. 
            Note: is is assumed that left and right are reference counted before call.
            The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Subtraction(System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Subtract right from left
            Note: is is assumed that left and right are reference counted before call.
            The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Multiplication(System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Multiply two BddFds
            Note: is is assumed that left and right are reference counted before call.
            The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.ShiftLeft(System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Create BddFd that represents this input where all Bdds are shifted
            count to the left, and BddFalse are shifted in from the right
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.ShiftRight(System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Create BddFd that represents this input where all Bdds are shifted
            count to the right, and BddFalse are shifted in from the left
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.IfThenElse(System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Create BddFd representing If-Then-Else
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Apply(System.Int32,System.Int32,Configit.Core.Noddy.Operators.BddOpr,Configit.Core.Noddy.Kernel.BddRef)">
            <summary>
            Helper method to handle ref count when applying two Bdds. Args must be
            reference counted when calling this method 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.Not(System.Int32,Configit.Core.Noddy.Kernel.BddRef)">
            <summary>
            Helper method to handle ref count when negating Bdd. Root must be
            reference counted when calling this method 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.InitRes(System.Int32[])">
            <summary>
            Get Bdd array initialized with BddFalse, possibly re-using existing array
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.BuildFdVarInfo(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Build up encoding arrays representing Fdvars, and ensure there are enough Bdd
            variables to encode the requested finite domain variables
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.BuildFdVarsAndBddToEncoding">
            <summary>
            Build int[] array representation of each fd variable used every time <see cref="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVar(System.Int32)"/> is 
            called. Also build up domain constraints.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.ApplyDomainConstraintsToBdd(System.Int32)">
            <summary>
            Traverse Bdd, identify references to finite domain variables, and apply
            domain constraints for these. Input root need not be  
            reference counted. Result is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.RelaxDomainConstraints(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Relaxes the domain constraints in the bdd such that any path involving
            values not allowed by the domain constraint will be valid.
            </summary>
            <param name="root">The bdd to relax, must be reference counted.</param>
            <param name="variables">The finite domain variables for which to relax the domain constraint,
            if none are specified all the variables used in <paramref name="root"/> are relaxed</param>
            <returns>A relaxed bdd that is not reference counted.</returns>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.MarkReferencedFdVars(System.Int32)">
            <summary>
            Recursive method for identifying which fdvars are used in Bdd
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarCountInSupport(System.Int32)">
            <summary>
            Get number of finite domain variables in <see cref="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarSupport(System.Int32)"/> of root.
            Uses cached value, so this might be faster than calling Count() on the result
            of <see cref="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarSupport(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarSupport(System.Int32)">
            <summary>
            Returns the finite domain variables used in the bdd. Variables
            are sorted according to variable number
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarForRoot(System.Int32)">
            <summary>
            Get finite domain variable represented by root. 
            </summary>
            <remarks><see cref="P:Configit.Core.Noddy.FiniteDomain.FdOperations.FdVarCount"/> if used on terminal roots, -1 if no 
            finite domain variables have been defined. Otherwise, the finite domain variable
            that is the <see cref="P:Configit.Core.Noddy.Bdd.Var"/> encodes</remarks>
        </member>
        <member name="T:Configit.Core.Noddy.FiniteDomain.FdVarInfo">
            <summary>
            Information about the finite domain variables. 
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdVarInfo.Marked">
            <summary>
            Field used to mark / unmark finite domain variable
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdVarInfo.DomainSize">
            <summary>
            Number of values in domain of finite domain variable. Max allowed number is 2^26 = 67108863
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdVarInfo.EncodingSize">
            <summary>
            Number of bits used to encode domain
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.FiniteDomain.FdVarInfo.EncodingVariables">
            <summary>
            The BDD variables used to encode the finite domain variable
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.FiniteDomain.FdVarInfo.GetEncodingSize">
            <summary>
            Get number of bits required to encode specified domain size
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.FiniteDomain.NamespaceDoc">
            <summary>
            Representing finite domain variables as an array of of <see cref="T:Configit.Core.Noddy.Bdd"/>s
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.IO.BddIoManager">
            <summary>
            Class used for managing import and export of BDDs. This is used
            both for debug print and for save / load
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.IO.BddIoManager.PrintBddAsText(System.IO.TextWriter,System.Int32)">
            <summary>
            <para>
            Print the table entries reachable from the root BDD. Entries
            are printed as text in the format
            </para>
            <para>Node:Var:Low:High</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.IO.BddIoManager.PrintBddAsDot(System.IO.TextWriter,System.Int32,System.Boolean)">
            <summary>
            Output Bdd from root downwards in Graphviz format.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.IO.BddIoManager.PrintBddAsDotRec(System.IO.TextWriter,System.Int32,System.Boolean)">
            <summary>
            Recursive function that prints Bdd in Graphviz format
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.IO.BddIoManager.PrintBddAsTextRec(System.IO.TextWriter,System.Int32)">
            <summary>
            Recursive function that prints BDD as text
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.IO.BddIoManager.Save(System.IO.TextWriter,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Save normalized BDDs in mime encoded format
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.IO.BddIoManager.Save(System.IO.TextWriter,System.Int32,System.Boolean)">
            <summary>
            Save normalized BDD in mime encoded format, if <paramref name="backwardsCompatible"/> is set
            then finite domain information is not generated.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.IO.BddIoManager.Load(System.IO.TextReader,Configit.Core.Noddy.IO.FiniteDomainHandling,Configit.Core.Noddy.IO.NodePreAllocation)">
            <summary>
            Load BDD from stream reader. Resulting BDD is not reference counted
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.IO.FiniteDomainHandling">
            <summary>
            Defines how finite domain information is used when loading serialized bdds.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.IO.FiniteDomainHandling.Ignore">
            <summary>
            Ignore serialized finite domains.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.IO.FiniteDomainHandling.Replace">
            <summary>
            Replace the current finite domain definition with the serialized one.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.IO.FiniteDomainHandling.Verify">
            <summary>
            Verify that the serialized finite domain definitions are compatible with the current
            finite domain definitions. They are consider compatible if they are a subset of the current
            finite domains. 
            <example>
            If the serialized <see cref="T:Configit.Core.Noddy.Bdd"/>s defines domains of size 2,2,3 and the current domains are 2,2,3,2 then the load succeeds.
            If the current domains are 5,5,5,5 or 2,2 it fails.
            </example>
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.IO.NamespaceDoc">
            <summary>
            Setting for how to handle BDDs when they are serialized and de-serialized
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.IO.NodePreAllocation">
            <summary>
            Defines memory allocation behavior when loading bdds.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.IO.NodePreAllocation.None">
            <summary>
            No pre-allocation of nodes, table will re-size dynamically as nodes are processed.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.IO.NodePreAllocation.Aggressive">
            <summary>
            Assume that there will be no shared nodes between the current node table and node 
            that will be loaded, and make sure the node table can contain both existing and new 
            nodes.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.BddKernel">
            <summary>
            The BDD kernel handles the creation and house keeping of BDD
            nodes and BDD caches
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddKernel.BddFalse">
            <summary>
            Index of BDD representing false (terminal node)
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddKernel.BddTrue">
            <summary>
            Index of BDD representing true (terminal node)
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddKernel.Maxref">
            <summary>
            Max number of references any node can have (10 bit)
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddKernel.DefaultMaxNodeSize">
            <summary>
            Default upper limit for maximum allowed nodes in the BDD table
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.MaxNodeIncrease">
            <summary>
            Max number of nodes to increase the node table with 
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.NodeTableSize">
            <summary>
            Number of allocated nodes in BDD node table
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.MinFreeNodesRatio">
            <summary>
            Min. number of nodes (in %) that has to be left after a garbage collect
            unless a resize should be done
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.MaxNodeSize">
            <summary>
            Maximum number of nodes that the table can be extended with. 
            Default is 2^30-1. Cannot be set to a value larger than the default value
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.FreeNodes">
            <summary>
            Returns the current number of free nodes in the table
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.BddVarCount">
            <summary>
            Number of supported BDD variables. Number can be change multiple times
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.#ctor(System.Int32,System.Int32,System.Int32,Configit.Core.Noddy.Events.EventRegistrator)">
            <summary>
            The constructor initializes the BDD node table, and 
            </summary>
            <param name="nodeSize">Number of BDD nodes. Each nodes takes up 20 bytes</param>
            <param name="minCacheSize">Minimum number of entries in the cache table</param>
            <param name="cacheRatio">Ratio between BDD nodes and cache nodes</param>
            <param name="eventRegistrator">Registered events</param>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.MakeNode(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create node with specified level, low and high. If node already exist, the 
            existing node is returned. If no free spaces are available in node table,
            the garbage collection is called and the node table could be expanded
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.BddVar(System.Int32)">
            <summary>
            Get BDD representing the I'th variable, where high son points to <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddTrue"/> and 
            low son points to <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddFalse"/>. The requested variable must be in the 
            less than <see cref="P:Configit.Core.Noddy.Kernel.BddKernel.BddVarCount"/>, otherwise <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddFalse"/> is returned.
            The returned BDD should NOT be reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.NegBddVar(System.Int32)">
            <summary>
            Get BDD representing the I'th variable, where high son points to <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddFalse"/> and 
            low son points to <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddTrue"/> The requested variable must be in the 
            less than <see cref="P:Configit.Core.Noddy.Kernel.BddKernel.BddVarCount"/>, otherwise <see cref="F:Configit.Core.Noddy.Kernel.BddKernel.BddFalse"/> is returned.
            The returned BDD should NOT be reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.Low(System.Int32)">
            <summary>
            Get the false branch of a BDD. CheckRoot() should be called first
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.High(System.Int32)">
            <summary>
            Get the true branch of a BDD. If called from the outside, CheckRoot() should be called first
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.Var(System.Int32)">
            <summary>
            Get the variable for the BDD. CheckRoot() should be called first
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.RefCount(System.Int32)">
            <summary>
            Get the reference count for BDD
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.RefCountedBdds(System.Boolean)">
            <summary>
            Get reference counted BDDs
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.CheckRoot(System.Int32)">
            <summary>
            Ensure that a BDD root is valid. If not, throw exception
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.CheckRootRecursively(System.Int32)">
            <summary>
            Used for internal debug. Check that root + all children of root are valid
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.IncRef(System.Int32,System.Int32)">
            <summary>
            Increment ref count on root. Remember to call <see cref="M:Configit.Core.Noddy.Kernel.BddKernel.DecRef(System.Int32,System.Int32)"/> to release
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.DecRef(System.Int32,System.Int32)">
            <summary>
            Decrement ref count on root, after it has been incremented by <see cref="M:Configit.Core.Noddy.Kernel.BddKernel.IncRef(System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.IsConst(System.Int32)">
            <summary>
            Check if BDD represents a terminal root
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.AllNodesUnmarked">
            <summary>
            True if all nodes are marked. This is decided by running through all nodes in 
            the BDD table. This method is only provided for used internally for asserting
            sanity of marking algorithms.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.SanityCheckRefCountedBdds">
            <summary>
            Sanity check all roots which have an external reference count. Provided
            for internal debug only. Throws exception on error.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.SanityCheckBdd(System.Int32,System.Boolean)">
            <summary>
            Internal method provided to check that all nodes in BDD are indeed
            marked as used. Provided for debug purposes only. Throws exception if this is not the case.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.EnsureNodeSize(System.Int32)">
            <summary>
            Ensures that the node table size has at least the given size. The resize
            is allowed to exceed <see cref="P:Configit.Core.Noddy.Kernel.BddKernel.MaxNodeIncrease"/>, but not <see cref="P:Configit.Core.Noddy.Kernel.BddKernel.MaxNodeSize"/>
            <see cref="M:Configit.Core.Noddy.Noddy.EnsureNodeTableCapacity(System.Int32)"/>
            </summary>
            <returns>True if successful, false if <see cref="P:Configit.Core.Noddy.Kernel.BddKernel.MaxNodeSize"/> would be exceeded.</returns>
            <exception cref="T:System.OutOfMemoryException">If the required memory cannot be allocated</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.ResizeTable(System.Boolean,System.Int32)">
            <summary>
            Resize node table, making room for more nodes.
            Returns true on success, false if we have reached the maximum allowed
            number of nodes specified in <see cref="P:Configit.Core.Noddy.Kernel.BddKernel.MaxNodeSize"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.RehashBddTable">
            <summary>
            Re-hash all used nodes in table. Typically called after the
            table has been resized.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.MarkRecursively(System.Int32)">
            <summary>
            Mark the BDD from current root downwards to all children
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.UnMarkRecursively(System.Int32,System.Boolean)">
            <summary>
            Un-mark all marks set using <see cref="M:Configit.Core.Noddy.Kernel.BddKernel.SetMark(System.Int32)"/> in the BDD from current
            root downwards to all children. If <paramref name="removeMark2"/>
            is set, it will also remove marks set by <see cref="M:Configit.Core.Noddy.Kernel.BddKernel.SetMark2(System.Int32)"/>.
            Note: it uses marks set by <see cref="M:Configit.Core.Noddy.Kernel.BddKernel.SetMark(System.Int32)"/> to control the
            recursion.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.RemoveMark(System.Int32)">
            <summary>
            Remove mark on specific BDD (not recursive)
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.SetMark(System.Int32)">
            <summary>
            Set mark on specific BDD (not recursive)
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.SetMark2(System.Int32)">
            <summary>
            Set the second mark.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.IsMarked(System.Int32)">
            <summary>
            Return true if the BDD is marked, false otherwise
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.IsMarked2(System.Int32)">
            <summary>
            Return true if mark 2 has been set. 
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.CacheManager">
            <summary>
            Manager of all caches
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddKernel.Statistics">
            <summary>
            Statistics about the usage of this instance
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.GarbageCollect">
            <summary>
            Reclaim any non-used nodes in node table
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.Pair(System.UInt32,System.UInt32)">
            <summary>
            Pair hash function taken from HRA's lecture notes
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddKernel.MoveBddToThisInstance(Configit.Core.Noddy.Kernel.BddKernel,System.Int32)">
            <summary>
            Move BDD from one Noddy instance to this instance. Both this and the other
            kernel should be locked before calling this operation
            Result is not reference counted.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.BddNode">
            <summary>
            Representation of a BDD node in the node table. A BDD node is 
            represented by 5 32bit integers = 20 bytes.
            There can max be 2^31 nodes in the table.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.Level">
            <summary>
            BDD variable index. There can be max 2097151 variables in the package
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.Marked">
            <summary>
            Used for marking and unmarking the node
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.Marked2">
            <summary>
            Used for marking roots (for example used to mark NDD roots in NDD conversion)
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.RefCount">
            <summary>
            Number of times the node is referenced externally
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.Low">
            <summary>
            BDD node for low child - representing false branch
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.High">
            <summary>
            Bdd node for high child - representing true branch
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.Hash">
            <summary>
            Pointer to BDD node that contains entry matching hash lookup
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddNode.Next">
            <summary>
            If node is unused Next points to next free node. If node is used Next
            points to next node matching same hash value
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.BddPriorityKey">
            <summary>
            Used when sorting BDDs for eg. multi conjoin and multi disjoin
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.BddRef">
            <summary>
            Definition if the reference count of the BDD is increased before 
            being returned
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddRef.IncDec">
            <summary>
            Reference count of result is incremented before being returned.
            Reference count of arguments are decremented when operation is
            complete
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddRef.Inc">
            <summary>
            Reference count of result is incremented before being returned.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddRef.Dec">
            <summary>
            Reference count of arguments are decremented when operation is
            complete
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.BddRef.None">
            <summary>
            Result is not reference counted, and referenc count on arguments
            are not changed
            </summary>,
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.BddStats">
            <summary>
            Statistics about the usage of a specific <see cref="T:Configit.Core.Noddy.Noddy"/>
            instance. Contains information such as how many garbage collections 
            have been performed, how long time table resize has taken etc.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddStats.ToString">
            <summary>
            Print statistics
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.GbEllapsedMillisec">
            <summary>
            Number of milliseconds used in total for BDD Node garbage collection
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.GbCollectNum">
            <summary>
            Number of times the garbage collector has been called
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.DotNetGbCollectCount">
            <summary>
            Number of times a full .Net garbage collection has been invoked
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.GcCollectNumbers">
            <summary>
            Get the number of times the garbage collector has been called for each resize
            of the table. The number of entries corresponds to the number of entries in 
            <see cref="P:Configit.Core.Noddy.Kernel.BddStats.BddTableSizes"/>. The i'th index is the number of times the garbage
            collector was called when the BDD table was of size <see cref="P:Configit.Core.Noddy.Kernel.BddStats.BddTableSizes"/>[i]
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.ResizeEllapsedMillisec">
            <summary>
            Number of milliseconds used in total for resizing table
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.MultiOprCacheMillisec">
            <summary>
            Number of milliseconds used in total for flushing Multi Operations Cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.ResizeCount">
            <summary>
            Number of times the BDD node table has been resized
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.BddTableSizes">
            <summary>
            The size of the BDD node table as it has grown over time. The first entry
            specifies the initial size of the table, the following entries 
            shows how much the the table has grown
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.CacheTableSizes">
            <summary>
            The size of the cache table as it has grown over time. The first entry
            specifies the initial size of the table, the following entries 
            shows how much the the table has grown
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.ApplyCacheHit">
            <summary>
            Number of times result of apply operation is found in cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.SimplifyCacheHit">
            <summary>
            Number of times result of simply operation is found in cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.MultiApplyCacheHit">
            <summary>
            Number of times result of multi apply operation is found in cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.MultiApplyCacheMiss">
            <summary>
            Number of times multi apply operation could not find result in cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.QuantCacheHit">
            <summary>
            Number of times result of quantification operation is found in cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.RestrictCacheHit">
            <summary>
            Number of times result of restrict operation is found in cache
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.MakeNodeCount">
            <summary>
            Total number of nodes created during the lifespan of the Noddy instance
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.ApplyCount">
            <summary>
            Number of times BDD apply has been called
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.QuantCount">
            <summary>
            Number of times BDD quantification has been called
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.ApplyQuantCount">
            <summary>
            Number of times BDD combined apply/quant has been called
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.BddMoveCount">
            <summary>
            Number of times a BDD has been moved from another Noddy instance to
            this instance
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.FdCompareCount">
            <summary>
            Number of times two <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s have been compared, resulting
            in a <see cref="T:Configit.Core.Noddy.Bdd"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.FdCalculateCount">
            <summary>
            Number of calculations created using <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.DomConstrElapsedMillisec">
            <summary>
            Number of milliseconds used in total to apply domain constraints
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.DomConstrCount">
            <summary>
            Number of times domain constraints have been applied to a BDD
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.RecursiveSplitCacheMiss">
            <summary>
            Number of times recursive split has missed the cache, and actually calculated the split
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.RecursiveSplitCacheHit">
            <summary>
            Number of times recursive split had cached that root could not be split
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.SplitOnTopRootCount">
            <summary>
            Number of times the split operation has been called on a root. The top split
            call will call recursively on each split result
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.SplitSinglePathCount">
            <summary>
            Number of splits performed on single-path BDDs. A number of the <see cref="P:Configit.Core.Noddy.Kernel.BddStats.RecursiveSplitCacheMiss"/>
            can be single path splits.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.SimplifyRelaxCount">
            <summary>
            Number of simplify / relax operations performed.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.BddStats.SatisfyCount">
            <summary>
            Number of satisfiability checks performed 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddStats.AddGcCount">
            <summary>
            Called when the garbage collector is run
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BddStats.AddTableSizes(System.Int32,System.Int32)">
            <summary>
            Called when the Bdd node table is expanded
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.BinaryOperations">
            <summary>
            Binary operators on BDDs
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.Apply(System.Int32,System.Int32,Configit.Core.Noddy.Operators.BddOpr,Configit.Core.Noddy.Kernel.BddRef)">
            <summary>
            Helper method to handle ref count when applying two BDDs. 
            Note: It is assumed that the input operands are reference counted throughout the operation.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.MultiApply(System.Int32[],Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            Conjoin or disjoin multiple BDDs in one go. 
            Arguments should be checked before calling this operation.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.ApplyAsBalancedTree(System.Collections.Generic.List{System.Int32},Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            Will apply binary operator on a list of BDDs, as if they were all organized in a balanced
            tree (which makes e.g. disjoin faster)
            Arguments should be checked before calling this operation.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.Satisfy(System.Int32[],System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Noddy.Noddy.Satisfy(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)"/>.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.IsSatisfiable(System.Int32[],System.Int32)">
            <summary>
            <see cref="M:Configit.Core.Noddy.Noddy.IsSatisfiable(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)"/>.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.Apply(System.Int32,System.Int32,Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            For performing basic binary operations on BDDs, such as AND, OR etc. 
            Arguments should be checked before calling this operation.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.CheckEasyApplyOfConstants(System.Int32,System.Int32,Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            Check if the apply result can be easily determined when one of the arguments is a constant
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.Not(System.Int32)">
            <summary>
            Negate the BDD by replacing all references to <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> with 
            references to the <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/> and vice versa.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.ApplyAndQuantify(System.Int32,System.Int32,Configit.Core.Noddy.Operators.BddOpr,System.Collections.Generic.IEnumerable{System.Int32},Configit.Core.Noddy.Kernel.QuantRestrictOpr)">
            <summary>
            Perform apply and quantify in one operation. This is more efficient than 
            first applying, then quantifying.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            </summary>
            <example>
            Unique (XOR) quantification is not supported. The following example would fail:
            <code>
            Bdd a = _noddy.NegBVar( 1 );
            Bdd b = ( _noddy.BddVar( 0 ) == _noddy.BddFalse ) &gt; a;
            Bdd two = ( a &amp; b ).Unique( 0 );
            Bdd one = a.ApplyUnique( b, BddOpr.And, 0 );
            </code>
            </example>
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.CheckEasyApplyQuantOfConstants(System.Int32,System.Int32,Configit.Core.Noddy.Operators.BddOpr,Configit.Core.Noddy.Kernel.QuantRestrictOpr)">
            <summary>
            Check if the apply result can be easily determined when one of the arguments is a constant
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.Quantify(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},Configit.Core.Noddy.Kernel.QuantRestrictOpr)">
            <summary>
            Perform quantification (exist/forall/unique) of all BDD variables in bddVars
            on Bdd represented by root. 
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.SimplifyOrRelax(System.Int32,System.Int32,Configit.Core.Noddy.Operators.OtherBddOpr)">
            <summary>
            Simplify root, removing information which is already in other BDD
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.Restrict(System.Int32,System.Int32)">
            <summary>
            Restrict root BDD to path represented by constant.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.SetRestrictConstants(System.Int32)">
            <summary>
            Traverse single path BDD to determine constant values for restrict. Return 
            highest variable number to restrict
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.ExtractSinglePathConstants(System.Int32)">
            <summary>
            Constructs a Bdd representing the single path consisting of all BDD variable
            constants in the input Bdd. I.e. a BDD variable will occur in the resulting
            BDD if all satisfying paths in the input BDD requires the same truth assignment
            to that BDD variable.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.SatCount(System.Int32)">
            <summary>
            Calculate the number of possible different variable assignments there exist
            such that the BDD is satisfied.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.SatCountRec(System.Int32)">
            <summary>
            Recursive call to satcount 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.UniqueNodeCount(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Counts the unique number of nodes in a set of bdds
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.NodeCount(System.Int32)">
            <summary>
            Count the number of nodes used to represent a Bdd
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.NodeCountRec(System.Int32)">
            <summary>
            Recursively call to NodeCount
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.IsSinglePath(System.Int32)">
            <summary>
            Efficient way of checking whether the bdd is a single path.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.VarCountInSupport(System.Int32)">
            <summary>
            Get number of finite domain variables in <see cref="M:Configit.Core.Noddy.Kernel.BinaryOperations.Support(System.Int32)"/> of root.
            Uses cached value, so this might be faster than calling Count() on the result
            of <see cref="M:Configit.Core.Noddy.Kernel.BinaryOperations.Support(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.Support(System.Int32)">
            <summary>
            Returns a set of binary variable indices corresponding to those variables
            that occur in the bdd. Result is sorted by variable order
            </summary>
            <param name="root">The node index of the root bdd node</param>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.ConstAssignments(System.Nullable{System.Boolean}[])">
            <summary>
            Create Bdd representing assignment of const values to BDD variables.
            Note: Result is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.BinaryOperations.SinglePathBddForVariables(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create single path BDD which represents specified BDD variables. Low 
            path leads to false, high path leads to next variable
            Note: Result is not reference counted.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.ExternalReferenceHandler">
            <summary>
            Stores WeakReferences to any <see cref="T:Configit.Core.Noddy.Bdd"/> and <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> object that have been created. Upon <see cref="T:Configit.Core.Noddy.Kernel.BddKernel"/> garbage collection 
            the weak reference collections are updated to decrement reference count on any unused BDDs.
            Note, that the above involves forcing a full .Net garbage collection.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.ExternalReferenceHandler.ExternalRefCreatedSinceLastGb">
            <summary>
            Set to true each time an external <see cref="T:Configit.Core.Noddy.Bdd"/> is created, allowing GB to
            figure out when to force collection of external dead objects
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ExternalReferenceHandler.CleanDeadExternalRootsBeforeGc(System.Boolean)">
            <summary>
            Before garbage collection starts in the kernel, we need to de-reference any unused external roots.
            </summary>
            <param name="ensureFullGc">If true, a full .Net GB will always be run</param>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.KernelLockOrder">
            <summary>
            Order to lock kernels to avoid deadlock. Order is found 
            by internal comparison of the two kernels
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.KernelLockOrder.#ctor(Configit.Core.Noddy.Noddy,Configit.Core.Noddy.Noddy)">
            <summary>
            Given two <see cref="T:Configit.Core.Noddy.Noddy"/> instances detect which Noddy kernel to 
            lock first to avoid deadlocks
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.KernelLockOrder.First">
            <summary>
            First kernel to lock
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.KernelLockOrder.Second">
            <summary>
            Second kernel to lock
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.MaxNodeTableSizeExceeded">
            <summary>
            Thrown when a <see cref="T:Configit.Core.Noddy.Kernel.BddKernel"/> needs more than the maximum possible number of nodes to proceed.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.MaxNodeTableSizeExceeded.Message">
            <inheritdoc />
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.MultiApply">
            <summary>
            Operations that applies multiple BDDs in one operation.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.MultiApply.Apply(System.Int32[],Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            Conjoin or disjoin multiple BDDs in one go. 
            Arguments should be checked before calling this operation.
            Note: It is assumed that the input operands are reference counted throughout the operation.
            Note: The result is not reference counted.
            <exception cref="T:System.ArgumentException">If any of the arguments are invalid</exception>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.MultiApply.MultiApplyRec(System.Int32,System.Int32)">
            <summary>
            Result is not reference counted. It is assumed that all roots from
            offset to offset+length-1 contain no terminal nodes. It is assumed
            that there are no duplicates and that all roots are sorted.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.MultiApply.ChangeRootDelegate">
            <summary>
            Delegate + methods used for converting root to high/low during recursion
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.MultiApply.PruneMultiApplyRoots(Configit.Core.Noddy.Kernel.MultiApply.ChangeRootDelegate,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Remove all don't care roots. Return root node if result can be easily deduced,
            -1 otherwise. Updates length to reflect removal of don't care roots.
            Will also move + update roots if appropriate rootOpr and move arguments
            are given - this is used when traversing down low/high branch, where
            the updated low/high nodes are moved to a new position.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.MultiApply.Satisfy(System.Int32[])">
            <summary>
            <see cref="M:Configit.Core.Noddy.Noddy.Satisfy(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)"/>.
            Note: It is assumed that the input operants are reference counted throughout the operation.
            Note: The result is not reference counted.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.MultiApply.SortAndMoveDistinct(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Collections.Generic.IComparer{System.Int32})">
            <summary>
            Given a source array which is presorted from 0 to <paramref name="firstUnsortedIdx"/>, sorts elements in source, removes duplicates, and copies
            result to <paramref name="targetArray"/> starting at <paramref name="firstTargetIdx"/>
            </summary>
            <returns>Number of distinct elements</returns>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.MultiApplyComparer">
            <summary>
            Comparer of BDD nodes. Sort first by variable number, then by root number
            Compares to be used for sorting in descending order.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.MultiApplyComparer.Compare(System.Int32,System.Int32)">
            <summary>
            Compare BDD roots first by variable index, then by root. Descending order
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.NamespaceDoc">
            <summary>
            Internal kernel of the BDD package, taking care of all operations on BDDs
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.Primes">
            <summary>
            Class for working on Prime numbers
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.Primes.IsPrime(System.Int32)">
            <summary>
            Test if a number is a prime number. Taken from
            http://dotnetperls.com/prime
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.Primes.GetNextPrime(System.Int32)">
            <summary>
            Get the next prime that is larger or equal to the specified input
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.PrivateVarPriorityKey">
            <summary>
            Used to prioritize Roots, in an attempt to remove private variables 
            in an efficient manner
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.QuantRestrictOpr">
            <summary>
            Enumeration of operators that can be used for quantification
            and restriction. Operators are used for creating ID value 
            that are used in caching
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Kernel.ValidValues">
            <summary>
            Module used to find valid values in a BDD
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.ValidValues.BitFalse">
            <summary>
            Value used to mark that bit in path is decisively false
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.ValidValues.BitTrue">
            <summary>
            Value used to mark that bit in path is decisively true
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Kernel.ValidValues.BitUndef">
            <summary>
            Value used to mark that bit in path is undefined
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Kernel.ValidValues.Kernel">
            <summary>
            BDD kernel instance
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ValidValues.Initialize(System.Int32)">
            <summary>
            Called before each operation, to ensure internal memory is initialized
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ValidValues.FindValidValues(System.Int32,System.Int32)">
            <summary>
            Find valid values for specific <paramref name="fdVar"/> in BDD. The BDD need not be reference counted,
            no new nodes are created during this operation.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ValidValues.FindValidValues(System.Int32)">
            <summary>
            Find valid FD variable values in BDD. The BDD need not be reference counted,
            no new nodes are created during this operation.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ValidValues.ValuesMarkedAsValidForVariable(System.Int32)">
            <summary>
            Get representation of values marked as valid for specific variable
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ValidValues.MarkValuesForTopRoot(System.Int32,System.Int32)">
            <summary>
            Mark values represented by paths leading from top root
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ValidValues.MarkTopRootsAndFindValidValues(System.Int32,System.Int32,System.Int32)">
            <summary>
            Iterate through BDD, identifying top roots. For each relevant top
            root, values that can be reached from the top root are marked as valid.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Kernel.ValidValues.CreateValuesForPath(System.Int32,System.Int32,System.Int32)">
            <summary>
            Look at path bits for given FD variable, and mark all represented
            values as being valid
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.NamespaceDoc">
            <summary>
            Main classes for working with Binary Decision Diagrams
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.NamespaceGroupDoc">
            <summary>
            Representation and operations on Boolean Formulas. On lowest level, all Boolean 
            logic is represented in a <see cref="T:Configit.Core.Noddy.Noddy"/> instance, representing a collection 
            of <see cref="T:Configit.Core.Noddy.Bdd"/>s. This module provides all low-level operations required to 
            build internal structures for logic models and operations on these logic models
            (e.g. configration, analysis, optimizations etc.).
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Noddy">
            <summary>
            <para>
            Noddy is Our Decision Diagram package, used for building and manipulating decision diagrams.
            It provides a package for manipulating decision diagrams. Each instance of Noddy
            is an entity that stores a number of <see cref="T:Configit.Core.Noddy.Bdd"/>s and handles a set of
            defined finite domain variables.
            The package can create atomic BDDs representing true/false/a BDD variable, and
            provide atomic finite variable expressions representing integer constants and
            finite domain variable encodings.
            </para>
            <para>Operations can be applied to <see cref="T:Configit.Core.Noddy.Bdd"/>s and <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s
            allowing for the construction of advanced Boolean expressions
            over a set of Boolean variables.
            </para>
            <para>This package supports both Boolean operations and Boolean encoded
            finite-domain variables with basic integer operations.</para>
            <para>The theoretical max size of Noddy is: 2^31 BDD nodes, 2^21 BDD variables,
            2^26 values in each FD variable domain. Each BDD can max be referenced externally
            2^10 times</para>
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Noddy.StandardNodeSize">
            <summary>
            Standard number of nodes in a <see cref="T:Configit.Core.Noddy.Noddy"/> instance in 
            case no specific size is specified.
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Noddy.StandardCacheRatio">
            <summary>
            Standard value of <see cref="P:Configit.Core.Noddy.Noddy.CacheRatio"/> in a <see cref="T:Configit.Core.Noddy.Noddy"/> instance in 
            case no specific ration is specified.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>
            Construct a new Noddy instance used for creating Boolean functions.
            </summary>
            <param name="bddVarCount">Initial number of BDD variables supported. This can be
            increased by using <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/></param>
            <param name="nodeSize">Initial number of nodes in the Noddy instance. The node table 
            will automatically be expanded when required, but the expansion is an expensive process.
            Default size of BDD table is <see cref="F:Configit.Core.Noddy.Noddy.StandardNodeSize"/> nodes, which is approx. 20mb used for the node table.</param>
            <param name="minCacheSize">Minimum number of entries in the cache table. If set to 0, the
            cache size is automatically calculated based on the <see cref="P:Configit.Core.Noddy.Noddy.CacheRatio"/>.
            The performance of the operations depends on the size of the cache table</param>
            <param name="cacheRatio">Ratio between number of BDD nodes and nodes in cache tables. When
            the BDD node table is expanded, the size of the cache is set to the maximum of minCacheSize and
            BDD node size * cacheRatio</param>
            <param name="minFreeNodes">Minimum number of nodes (in %) that must be free after a garbage
            collection before the node table is expanded. Default is 20%. Can also be set by using
            <see cref="P:Configit.Core.Noddy.Noddy.MinFreeNodesRatio"/></param>
            <param name="maxNodeIncrease">When BDD node table is expanded, it is doubled by default. This
            value specifies the maximum number of nodes that it can be increased with in each expansion.
            Default value is <see cref="F:Configit.Core.Noddy.Noddy.StandardNodeSize"/> nodes which corresponds to about 20mb. Can be changed by setting
            <see cref="P:Configit.Core.Noddy.Noddy.MaxNodeIncrease"/></param>
            <param name="maxNodeSize">Maximum number of nodes that the BDD table can be increased to</param>
            <param name="finiteVarDomains">Set domain sizes of finite domain variables. Can be set using
            <see cref="P:Configit.Core.Noddy.Noddy.FiniteVarDomains"/>.</param>
            <param name="applyDomainConstraints">Automatically apply domain constraints for finite domain
            variables for any created BDD. This ensures that resulting BDDs always respects the 
            defined domain sizes of the finite domain variables. Can also be set using 
            <see cref="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints"/></param>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.EventRegistrator">
            <summary>
            Holder of events that client can register to for observing progress when using Noddy.
            All events are weak events, that is, they will not keep the client alive. 
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.Statistics">
            <summary>
            Get statistical information about the usage of this BddPackage. 
            Contains information such as how many garbage collections 
            have been performed, how long time table resize has taken etc.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.InstanceId">
            <summary>
            Each instance of Noddy has it's own ID which is set on creation time.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.CacheRatio">
            <summary>
            <para>
            Ratio (in percentage) between the size of the BDD node table and the cache tables. 
            The default value is 20%
            </para>
            <para>When the BDD node table is resized, the cache tables are initialized to the minimum
            of <see cref="P:Configit.Core.Noddy.Noddy.NodeTableSize"/> * <see cref="P:Configit.Core.Noddy.Noddy.CacheRatio"/> and the minCacheSize specified
            when initializing the <see cref="T:Configit.Core.Noddy.Noddy"/></para>
            <para>Valid values are [0;100]</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.NodeTableSize">
            <summary>
            Number of nodes currently allocated in the BDD node table
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.BddFalse">
            <summary>
            <para>
            Get <see cref="T:Configit.Core.Noddy.Bdd"/> representing false (terminal node)
            </para>
            <para>The terminal BDD nodes need not be reference counted as it will never be garbage collected</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.BddTrue">
            <summary>
            <para>
            Get <see cref="T:Configit.Core.Noddy.Bdd"/> representing true (terminal node)
            </para>
            <para>The terminal BDD nodes need not be reference counted as it will never be garbage collected</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.GetConstant(System.Boolean)">
            <summary>
            <para>
            Return the terminal BDD node representing specified Boolean constant</para>
            <para>The results is a terminal BDD nodes which need not be reference counted
            as it will never be garbage collected</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.BddVarCount">
            <summary>
            The number of used BDD variables used in the package. This number may be changed more than
            once. If changed to a number smaller than the current number of allocated BDD variables
            the change request is ignored.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.GetEncodingBddVars(System.Int32)">
            <summary>
            Returns the list of BDD variables used to encoded a given finite domain variable.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.GetEncodingBddVars(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Returns the set of BDD variables used to encode a set of finite domain variables.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.AllBddVariablesExcept(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Returns all the defined BDD variables not included in <paramref name="bddVars"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.AllBddVariables">
            <summary>
            Returns all the defined BDD variables as an enumeration.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.AllFdVariablesExcept(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Returns all the defined FD variables not included in <paramref name="fdVars"/>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.FdVarCount">
            <summary>
            The number of finite domain variables used in this <see cref="T:Configit.Core.Noddy.Noddy"/> instance. This number can be 
            changed by setting <see cref="P:Configit.Core.Noddy.Noddy.FiniteVarDomains"/>
            </summary>
            <returns>The number of finite domain variables declared, or -1 if no variables have
            been declared</returns>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.MaxNodeIncrease">
            <summary>
            Maximum number of nodes that the BDD node table is increased with when
            it runs out of space. By default, the node table will double in size, 
            but it will never increase with more nodes than specified by 
            MaxNodeIncrease. 
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.MaxNodeSize">
            <summary>
            <para>Maximum number of nodes that the BDD table can be increased to. If the BDD table
            grows to this size every newly created node will be identical to <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>.</para>
            <para>Valid range is 4 to 2^30-1. Default is the upper limit of this range</para>
            <para>The maximum size of the BDD nodes requires approximately 20GB of memory for the
            BDD table alone. Caching requires extra memory, size depends on <see cref="P:Configit.Core.Noddy.Noddy.CacheRatio"/>.</para>
            
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.MinFreeNodesRatio">
            <summary>
            Minimum number of free nodes that should be left after a garbage collection before
            BDD node table is resized. Given in percentage. Default is 20%.
            Valid values are [10;90]
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.BddVar(System.Int32)">
            <summary>
            <para>
            Get <see cref="T:Configit.Core.Noddy.Bdd"/> representing the i'th BDD variable, where high son points to <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> and 
            low son points to <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>. The requested variable must be in the 
            less than <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/>.
            </para>
            <para>The returned BDD need not be reference counted as it will never be garbage collected</para>
            </summary>
            <exception cref="T:System.ArgumentException">If variable number is outside the number of defined
            BDD variables defined by <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/></exception>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.FdVar(System.Int32)">
            <summary>
            <para>
            Get <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> representing the i'th finite domain variable. The requested variable must be 
            less than <see cref="P:Configit.Core.Noddy.Noddy.FdVarCount"/>
            </para>
            <para>The returned BddFd need not be reference counted as the internal <see cref="T:Configit.Core.Noddy.Bdd"/>s will 
            never be garbage collected</para>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.FdVars">
            <summary>
            Get array of all <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s representing the finite domain variables. Index i 
            in the result represents the result of calling <see cref="M:Configit.Core.Noddy.Noddy.FdVar(System.Int32)"/> with i.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.BddVars">
            <summary>
            Get array of all <see cref="T:Configit.Core.Noddy.Bdd"/>s representing individual BDD variables. Index i
            in the result represents the result of calling <see cref="M:Configit.Core.Noddy.Noddy.BddVar(System.Int32)"/> with i.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.FdConst(System.Int32)">
            <summary>
            <para>Get <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> representing a constant integer value</para>
            <para>The returned BddFd need not be reference counted as the internal <see cref="T:Configit.Core.Noddy.Bdd"/>s will 
            never be garbage collected</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.FdConstAssignment(System.Int32,System.Int32)">
            <summary>
            <para> Create BDD representing the assignment of a constant to a finite domain variable. 
            The result is a single path BDD. Using this method is faster than calculating the 
            equivalence of a finite domain variable with a finite domain constant.</para>
            <para>The result is identical to calling <code>noddy.FdVar(fdVar) == constant</code></para>
            </summary>
            <param name="fdVar">The index of the finite domain variable to assign to</param>
            <param name="constant">Constant to assign to variable. If constant is outside the
            domain of the finite domain variable the result is <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/></param>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.CheckFdVar(System.Int32)">
            <summary>
            Check that FD variable is valid. Throw <see cref="T:System.ArgumentException"/> if 
            index is outside valid bound.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.FdConstAssignments(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            <para>Create BDD representing assignments of a set of constants to a set of finite domain variables.
            The result is a single path BDD. Using this method is faster than calculating the conjunction
            of individual assignments to each finite domain variable.</para>
            <para>Negative values in constants are not assigned.</para>
            <para>Calling this method with constants = {0,17,-1,5} where x[] represents 
            <see cref="P:Configit.Core.Noddy.Noddy.FdVars"/>, the method returns a BDD representing
            <code>x[0]==0 &amp; x[1]==17 &amp; x[3]==5</code></para>
            </summary>
            <param name="constants">Constants to assign to the finite domain variables. 
            Only natural number constants are assigned. If a constant is negative, the value
            is not assigned. Constant in index i is assigned to finite domain variable with index i.</param>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.ConstantAssignments(System.Collections.Generic.IEnumerable{System.Nullable{System.Boolean}})">
            <summary>
            <para> Create a BDD representing assignments of a set of constants to a set of BDD variables.
            The result is a single path BDD. Using this method is faster than calculating the conjunction
            of individual assignments to each of the BDD variables</para>
            <para>null values in constants are not assigned.</para>
            <para>Calling this method with constants = {false,true,null,true} where b[] represents 
            a set of BDD variables, the method returns a BDD representing
            <code>!b[0] &amp; b[1] &amp; b[3]</code></para>
            </summary>
            <remarks>If the length of the constants array is longer than the number
            of BDD variables declared, the <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/> will automatically
            be expanded.</remarks>
            <param name="constants">Constants to assign to the finite domain variables. 
            Only true or false values are assigned. If a constant is null, the value
            is not assigned. Constant in index i is assigned to BDD variable with index i.</param>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.FdConstAssignments(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.FdValues})">
            <summary>
            <para>Create BDD representing assignments of a set of constants to a set of finite domain variables.
            The result is a single path BDD. Using this method is faster than calculating the conjunction
            of individual assignments to each finite domain variable.</para>
            </summary>
            <param name="assignments">Tuples representing variable,value assignments.</param>
            <returns>A BDD representing the conjunction of all assignments</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.NegBVar(System.Int32)">
            <summary>
            <para>
            Get BDD representing the i'th variable, where high son points to <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/> and
            low son points to <see cref="P:Configit.Core.Noddy.Noddy.BddTrue"/> The requested variable must be in the
            less than <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/>
            </para>
            <para>The returned BDD need not be reference counted as it will never be garbage collected</para>
            </summary>
            <exception cref="T:System.ArgumentException">If variable number is outside the number of defined
            BDD variables defined by <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/></exception>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.GetReferenceCountedRoots">
            <summary>
            Get list of internal root nodes which are marked as referenced in the Kernel.
            Before calculating this list, a full .Net garbage collection is called to try to
            collect any live <see cref="T:Configit.Core.Noddy.Bdd"/> and <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> classes.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.Algorithms">
            <summary>
            Access to collection of compilation algorithm working on this Noddy instance.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.BddIoManager">
            <summary>
            IO Manager that allows print for debug plus load / save of BDDs
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.Kernel">
            <summary>
            BDD kernel that package is running by
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.BinOperations">
            <summary>
            Binary BDD operations module
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.FdOperations">
            <summary>
            Finite domain operations module
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.ValidValues">
            <summary>
            Module used to find valid FdVar values in a BDD
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.ExternalReferenceHandler">
            <summary>
            Controls external references to BDDs.
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.FiniteVarDomains">
            <summary>
            <para>
            Domain sizes of finite domain variables. Each finite domain variable
            is encoded using Log2(domainsize) BDD variables. The <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/>
            is automatically increased if more BDD variables is needed to represent
            the finite variables.</para>
            <para>The numbers specified in the domains are the number of different values
            represented by the domain of each finite domain variable. The valid values
            are indexed from 0. That if,  if the domains are initialized as [2,3] there are
            two finite domain variables with domains: domain(var0)=[0;1], domain(var1)=[0;2]</para>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.FiniteVarDomain(System.Int32)">
            <summary>
            Get domain size of specific finite domain variable. 
            </summary>
            <exception cref="T:System.ArgumentException">If <paramref name="fdVar"/> is invalid or if no 
            finite domain variables have been defined</exception>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.ApplyDomainConstraints">
            <summary>
            <para>
            If ApplyDomainConstraints is true domain constraints are automatically applied to build BDDs.
            The domain constraints ensure that any finite domain variable can only be assigned 
            values that are within the size of the declared domain.</para>
            <para>Example: a finite domain variable is declared with a domain of size 9. It requires 4
            bits to encode 9 different values. If domain constraints are not applied, the finite domain 
            variable can take values [0;15]. If domain constraints are applied the finite domain variable
            can only take values in the declared domain which are [0;8].</para>
            <para>Domain constraints are applied with operation on finite domain variables results in
            a <see cref="T:Configit.Core.Noddy.Bdd"/> by calling <see cref="M:Configit.Core.Noddy.FiniteDomain.BddFd.Compare(Configit.Core.Noddy.FiniteDomain.BddFd,Configit.Core.Noddy.Operators.FddCompOpr)"/> and when calling <see cref="M:Configit.Core.Noddy.Bdd.Not"/>
            </para>
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.DomainConstraints">
            <summary>
            <see cref="T:Configit.Core.Noddy.Bdd"/> representing the conjunction of the domain constraints for all
            finite domain variables
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.DomainConstraint(System.Int32)">
            <summary>
            Get <see cref="T:Configit.Core.Noddy.Bdd"/> representing domain constraint for specified variable
            </summary>
            <exception cref="T:System.ArgumentException">If no FD variables are defined, or <paramref name="fdVar"/>
            is invalid</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.UniqueNodeCount(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Counts the number of unique nodes in a set of BDDs.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.MultiApply(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},Configit.Core.Noddy.Operators.BddOpr)">
            <summary>
            Apply multiple BDDs in one operation into a single BDD. Only conjunction 
            (<see cref="F:Configit.Core.Noddy.Operators.BddOpr.And"/>) and disjunction (<see cref="F:Configit.Core.Noddy.Operators.BddOpr.Or"/>) are 
            supported. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.Satisfy(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)">
            <summary>
            Try to find a BDD that satisfies the conjunction of the input BDDs. That is, a BDD that when
            conjoined with all BDDs in <paramref name="bdds"/> does not result in <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>.
            The result might not be identical to the conjunciton of the <paramref name="bdds"/>, 
            but might only represent a sub-set of the solutions in the conjunciton of the <paramref name="bdds"/>.
            This method should be significantly faster than
            conjoining the BDDs together as it only tries to find a solution instead of all solutions.
            </summary>
            <param name="bdds">BDDs to check.</param>
            <param name="preProcessConjoinLimit">Sets a limit on how large individual BDDs can be produced 
            during preprocessing before searching for a solution. Setting this to zero or less will disable
            the pre-processing.</param>
            <returns>BDD false if no solution exist, otherwise a BDD containing at least one solution</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.IsSatisfiable(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.Int32)">
            <summary>
            Check if there exist a solution for the conjunction of the given <paramref name="bdds"/>. 
            This method should be significantly faster than conjoining the BDDs together and checking if the conjunction <see cref="P:Configit.Core.Noddy.Bdd.IsFalse"/>
            </summary>
            <param name="bdds">BDDs to check.</param>
            <param name="preProcessConjoinLimit">Sets a limit on how large individual BDDs can be produced 
            during preprocessing before searching for a solution. Setting this to zero or less will disable
            the pre-processing.</param>
            <returns>True if conjunction does not result in <see cref="P:Configit.Core.Noddy.Noddy.BddFalse"/>, false otherwise</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.EnsureInThisNoddyInstance(Configit.Core.Noddy.Bdd)">
            <summary>
            <para>
            Ensures that input BDD exist in current Noddy instance. 
            If input BDD belongs to another Noddy instance
            it is copied to the current instance.</para>
            </summary>
            <returns>BDD belonging to the current instance</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.EnsureNodeTableCapacity(System.Int32)">
            <summary>
            Ensures that the node table size has at least the given size. The resize
            is allowed to exceed <see cref="P:Configit.Core.Noddy.Noddy.MaxNodeIncrease"/>, but not <see cref="P:Configit.Core.Noddy.Noddy.MaxNodeSize"/>
            </summary>
            <returns>True if successful, false if <see cref="P:Configit.Core.Noddy.Noddy.MaxNodeSize"/> would be exceeded.</returns>
            <exception cref="T:System.OutOfMemoryException">If the required memory cannot be allocated.</exception>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.EnsureAllInThisNoddyInstance(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            <para>
            Ensures that all input BDDs exist in current Noddy instance. If any input BDD belongs to another Noddy instance
            it is copied to the current instance.</para>
            <para>NOTE: Duplicates are removed from the result</para>
            </summary>
            <returns>BDD belonging to the current instance</returns>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.EnsureSequenceInThisNoddyInstance(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})">
            <summary>
            Same as <see cref="M:Configit.Core.Noddy.Noddy.EnsureAllInThisNoddyInstance(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd})"/> except that it doesn't remove duplicates.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.ExpandFiniteDomain(System.Int32,System.Int32)">
            <summary>
            <para>
            Expand the domain of a finite domain variable making it possible to assign larger
            values to that finite domain variable. All existing BDDs in the node table may be
            effected</para>
            <para>Example: if BDD variable 0,1 are used to encode FD variable 0 and BDD variable 2,3,4 are 
            used to encode FD variable 1, expanding FD variable 0 to domain size 6 will require an extra bit. The operation 
            will first introduce BDD variable 5, then run through the BDD table increasing the BDD variable
            index of all nodes that reference BDD variable 2 and above.</para>
            </summary>
            <param name="var">The index of the <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> for which to increase the domain</param>
            <param name="domSize">New size of domain</param>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.CheckVarNum(System.Int32)">
            <summary>
            Check that variable number is valid
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.LoadBdd(System.IO.TextReader,Configit.Core.Noddy.IO.FiniteDomainHandling,Configit.Core.Noddy.IO.NodePreAllocation)">
            <summary>
            Load BDD from text reader. The <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/> might 
            be increased if there is not enough BDD variables to represent
            the loaded BDD. If multiple BDDs are available, the first one is 
            returned.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.LoadBdds(System.IO.TextReader,Configit.Core.Noddy.IO.FiniteDomainHandling,Configit.Core.Noddy.IO.NodePreAllocation)">
            <summary>
            Load BDDs from text reader. The <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/> might 
            be increased if there is not enough BDD variables to represent
            the loaded BDDs. 
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.LoadBdd(System.String,Configit.Core.Noddy.IO.FiniteDomainHandling,Configit.Core.Noddy.IO.NodePreAllocation)">
            <summary>
            Load BDD from path. The <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/> might 
            be increased if there is not enough BDD variables to represent
            the loaded BDD
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.LoadBdds(System.String,Configit.Core.Noddy.IO.FiniteDomainHandling,Configit.Core.Noddy.IO.NodePreAllocation)">
            <summary>
            Load BDDs from path. The <see cref="P:Configit.Core.Noddy.Noddy.BddVarCount"/> might 
            be increased if there is not enough BDD variables to represent
            the loaded BDDs
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.SaveBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.IO.TextWriter)">
            <summary>
            Saves a collection of BDDs to a <see cref="T:System.IO.TextWriter"/>
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.SaveBdds(System.Collections.Generic.IEnumerable{Configit.Core.Noddy.Bdd},System.String)">
            <summary>
            Saves a collection of BDDs to a file
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Noddy.ForceGarbageCollection">
            <summary>
            Forces garbage collection regardless of free nodes
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Noddy.MultiOperationCache">
            <summary>
            Get cache used for holding intermediate results. This cache is typically used
            when multiple <see cref="T:Configit.Core.Noddy.Bdd"/>s are processed continuously using 
            operations in <see cref="P:Configit.Core.Noddy.Noddy.Algorithms"/>. The cache will hold results, thereby
            preventing the operations to repeat the same operation on the same BDDs.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Operators.BddOpr">
            <summary>
            BDD apply operators supported for operating on <see cref="T:Configit.Core.Noddy.Bdd"/>s
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.And">
            <summary>
            True when both arguments are true (operator &amp; )
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.Xor">
            <summary>
            True when arguments are different (operator ^)
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.Or">
            <summary>
            True when one of the arguments is true (operator | )
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.Nand">
            <summary>
            True if one of the arguments is false
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.Nor">
            <summary>
            True if both arguments are false
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.Imp">
            <summary>
            True if left is false or right is true (operator &gt; )
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.BiImp">
            <summary>
            True when arguments are equal (operator == )
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.Greater">
            <summary>
            True when left true and right is false
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.Less">
            <summary>
            True when right is true and left is false
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.BddOpr.InvImp">
            <summary>
            True when left is true or right is false (operator &lt; )"/>
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Operators.FddCalcOpr">
            <summary>
            Arithmetic operators supported for operating on <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCalcOpr.Add">
            <summary>
            Create the representation of adding two <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCalcOpr.Sub">
            <summary>
            Create the representation of subtracting one <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> from another
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCalcOpr.Mult">
            <summary>
            Create the representation of multiplying two <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCalcOpr.ShiftLeft">
            <summary>
            Shift all Bdd bits to the left, shifting in BddFalse from the right
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCalcOpr.ShiftRight">
            <summary>
            Shift all Bdd bits to the right, shifting in BddFalse from the left
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCalcOpr.Negation">
            <summary>
            Unary negation of integer value
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Operators.FddCompOpr">
            <summary>
            Comparison operators supported for operating on <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/>s
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCompOpr.Equal">
            <summary>
            Equality comparison. True for all BDD variable assignments that makes left and right equal
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCompOpr.Diff">
            <summary>
            Difference comparison. True for all BDD variable assignments that makes left and right different
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCompOpr.Lt">
            <summary>
            Less than comparison. True for all BDD variable assignments that makes left 
            hand side smaller than right hand side
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCompOpr.LtEq">
            <summary>
            Less or equal than comparison. True for all BDD variable assignments that makes left 
            hand side smaller or equal than right hand side
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCompOpr.Gt">
            <summary>
            Greater than comparison. True for all BDD variable assignments that makes left 
            hand side larger than right hand side
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.FddCompOpr.GtEq">
            <summary>
            Greater or equal than comparison. True for all BDD variable assignments that makes left 
            hand side larger or equal than right hand side
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Operators.NamespaceDoc">
            <summary>
            Operator definitions used when building up <see cref="T:Configit.Core.Noddy.Bdd"/>s as Boolean expressions and <see cref="T:Configit.Core.Noddy.FiniteDomain.BddFd"/> as 
            expressions over finite domain variables.
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Operators.OtherBddOpr">
            <summary>
            Operators used internally
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.OtherBddOpr.Not">
            <summary>
            Negate a Bdd
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.OtherBddOpr.Satcount">
            <summary>
            Get number of satisfiable solutions to Bdd
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.OtherBddOpr.BddMove">
            <summary>
            Move Bdd btwn. two Noddy instances
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.OtherBddOpr.PathCount">
            <summary>
            Get number of satisfiable paths in Bdd
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.OtherBddOpr.Simplify">
            <summary>
            Coudert and Madre's restrict function
            </summary>
        </member>
        <member name="F:Configit.Core.Noddy.Operators.OtherBddOpr.Relax">
            <summary>
            Coudert and Madre's restrict function modified to only relax bdds
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Util.IntPair">
            <summary>
            Represent a pair of integer values as an unsigned long. 
            The sequence of values in the pair matters. This helper class
            is provided to allow storing integer pairs in dictionaries in an easy way.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Util.IntPair.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct from the two elements
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Util.IntPair.First">
            <summary>
            First integer element in pair
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Util.IntPair.Second">
            <summary>
            Second integer element in pair
            </summary>
        </member>
        <member name="P:Configit.Core.Noddy.Util.IntPair.Key">
            <summary>
            Key (as a long) representing both integer elements in pair
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Util.IntPair.PairIsInSet(System.Func{System.Int32,System.Boolean})">
            <summary>
            Returns true if both the elements in this pair are considered alive, false otherwise.
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Util.IntPair.Equals(Configit.Core.Noddy.Util.IntPair)">
            <summary>
            True if <paramref name="other"/> is identical to this integer pair
            </summary>
        </member>
        <member name="M:Configit.Core.Noddy.Util.IntPair.GetHashCode">
            <summary>
            Get hash code for integer pair
            </summary>
        </member>
        <member name="T:Configit.Core.Noddy.Util.NamespaceDoc">
            <summary>
            Utility extensions and classes consumed by users of <see cref="T:Configit.Core.Noddy.Noddy"/>
            </summary>
        </member>
    </members>
</doc>
